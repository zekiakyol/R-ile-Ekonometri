[["index.html", "R ile Ekonometri Dersin amacı ve kapsamı", " R ile Ekonometri Prof. Dr. Hüseyin Taştan Yıldız Teknik Üniversitesi 2023-07-08 Dersin amacı ve kapsamı Bu dersin amacı R programı ile ekonometrik analizin temel düzeyde öğretilmesidir. Bu amaçla ilk olarak R programının temel ilkeleri tanıtılacak ve Tidyverse paketleri ile işlevselliğinin nasıl arttırılabileceği gösterilecektir. Ekonometrik analizin temelini oluşturan regresyon analizi, kesit-veri ve zaman serisi verileri için ayrı ayrı ele alınacaktır. Daha önce R ve ekonometri derslerini almış olmak gerekli değildir. Ancak üniversite düzeyinde istatistik bilgisi faydalı olabilir. Dersin sonunda katılımcılar R programını kendi uygulamalı ekonometrik analizlerinde kullanabilme becerisi edineceklerdir. "],["dersin-içeriği.html", "Dersin içeriği", " Dersin içeriği R programının tanıtımı Temel R R Tidyverse paketler topluluğunun tanıtımı Tidyverse paketleri tibble, tidyr, readr, dplyr ggplot2 ve diğerleri Kesit verilerle regresyon analizi lm() fonksiyonu Fonksiyon kalıpları Kukla değişkenler Etkileşim terimleri Hipotez testleri Zaman serileriyle regresyon analizi R’da zaman serisi nesneleri Zaman serilerinin temel özellikleri Zaman serilerinde bağımlılık ve durağanlık Statik ve dinamik zaman serisi modelleri Birim kök ve durağanlık testleri Vektör otoregresyon modeli ve Granger nedenselliği Eşbütünleşme ve hata düzeltme modelleri R Markdown ile raporlama ve tekrarlanabilir araştırma R kodları ile yorum ve açıklamaların birlikte hazırlanması Word, pdf, veya html gibi formatlara dönüştürülmesi Verilerin analize hazır hale getirilmesinden sonuçların elde edilmesine kadar tüm aşamaların raporlanması ve başkaları tarafından tekrarlanabilmesi/sonuçların yeniden üretilebilmesi "],["1-temelR.html", " 1 Temel R", " 1 Temel R R, istatistiksel hesaplama, programlama ve görselleştirme için geliştirilmiş özgür bir yazılımdır. R, veri manipülasyonu, hesaplama ve grafiksel gösterim için entegre bir yazılım paketidir. İçerisinde şunları barındırır: Etkili veri işleme ve depolama olanakları. Matris ve dizi hesaplamaları için çeşitli hesaplama araçları. Veri analizi için büyük, tutarlı, entegre bir araç koleksiyonu. Veri analizi ve gösterimi için ekran üzerinde veya çıktı alınan ortamda grafik araçları. Koşullu ifadelere, döngülere, kullanıcı tanımlı özyinelemeli fonksiyonlara ve giriş/çıkış olanaklarına sahip, iyi geliştirilmiş, basit ve etkili bir programlama dili. (Kaynak: https://www.r-project.org/about.html) Açık kaynaklı bir yazılım olan R dünya çapında geniş kullanıcı ağıyla sürekli geliştirilmektedir. R Foundation’a göre R’ı bir istatistik sistemi olarak düşünmek yerine onu istatistiksel tekniklerin uygulandığı bir ortam olarak düşünmek daha doğrudur. R, paketler aracılığıyla kolayca genişletilebilir. R dağıtımı ile birlikte sağlanan temel paketler ve çok daha fazlası, modern istatistik alanını kapsayan CRAN ailesi tarafından sunulan İnternet siteleri aracılığıyla erişilebilir. Detaylar için bkz. https://www.r-project.org/about.html "],["1.1-R-kurulum.html", "1.1 Kurulum", " 1.1 Kurulum R ve RStudio bilgisayarınızda yüklü değilse aşağıdaki adımları takip ederek yükleyebilirsiniz: Önce The Comprehensive R Archive Network adresinden R’ın sisteminize uygun en son versiyonunu indirerek kurunuz. Bu aşamada temel R fonksiyonlarını kullanmaya başlayabilirsiniz. Örneğin, Ancak standart R arayüzü ile kod yazmak, proje hazırlamak ve yönetmek kolay değildir. Bu işleri kolaylaştırmak için yaygın olarak kullanılan bir arayüz RStudio programıdır. RStudio sitesine giderek sisteminize uygun programı kurunuz. Her iki program da özgür (free) programdır. RStudio sadece bir arayüzden daha fazlasını sunmaktadır. RStudio ile bir R script dosyası oluşturarak yazdığınız kodları kaydedebilir ve daha sonra kullanabilirsiniz. Bunun için şu adımları takip ediniz: File &gt; New File &gt; R script. New file altında çok sayıda dosya biçimi dikkatinizi çekmiştir. Örneğin bu metin R Markdown dosya biçimi ile oluşturulmuştur. "],["1.2-R-console.html", "1.2 R Komut Satırı (Console)", " 1.2 R Komut Satırı (Console) Alt solda yer alan pencere R Console penceresidir. Burada doğrudan komutlarınızı çalıştırabilirsiniz. Kısa komutlar için pratik olsa da ciddi analizler için bir R Script dosyası tutmanız daha sağlıklı olacaktır. Komut satırında aritmetik işlemler 2 + 2 ## [1] 4 R’da yerleşik sabitler, \\(pi, e\\), Inf, NA, NaN pi ## [1] 3.141593 log(exp(-5)) ## [1] -5 e &lt;- exp(1) print(e, digits = 3) ## [1] 2.72 Atama işlemi = ya da &lt;- ile yapılabilir: e &lt;- exp(1) print(e, digits = 17) ## [1] 2.7182818284590451 Basit bir aritmetik işlem: \\[a = (9\\times 8.1) + 8.1\\] Sonuç: \\(10\\times 8.1 = 81\\). Komut satırında hesaplayalım: a &lt;- 9*8.1 + 8.1 print(a) ## [1] 81 Daha yakından bakalım: print(a, digits = 17) ## [1] 80.999999999999986 İkili sistem temsilindeki hata: print(81-a, digits = 17) ## [1] 1.4210854715202004e-14 Hata = \\(1.4210854715202004\\times 10^{-14}\\), ya da format(81-a, scientific = FALSE) ## [1] &quot;0.00000000000001421085&quot; Bu, yaptığınız hesaplamanın amacına bağlı olarak sorun yaratabilir. Örneğin yazdığınız programda bir aritmetik işlemin sonucunu başka bir sonuçla karşılaştırmak istediğinizi düşünelim. Bunun için mantıksal işlemcileri kullanabilirsiniz. Örneğin 81 == a ## [1] FALSE Bildiğimiz tam sonuç (81) ile aritmetik işlemin sonucu (a) eşit değil. Aslında eşit olduklarını biliyoruz. Ancak bilgisayar temsilinde (floating point arithmetic) yaklaşık olarak eşittirler: all.equal(81,a) ## [1] TRUE Burada default tolerans düzeyi \\(0.000000015\\) kullanıldı. Yani aritmetik çözüm ile tam sonuç arasındaki fark tolerans düzeyinden küçüktür. R’da makine hassasiyeti (\\(\\epsilon\\)) print(.Machine$double.eps, digits=22) ## [1] 2.220446049250313080847e-16 Alıştırma: Bilgisayarda temsil edilebilen 1’den küçük olan en büyük sayıyı bulunuz. Diğer aritmetik işlemler de sorun yaratabilir. Örneğin b &lt;- 10.2 - 10.1 print(b, digits = 17) ## [1] 0.099999999999999645 Bu tam sonuç \\(0.10\\) ile aynı değildir. Alıştırma 81 sayısının ikili sistemde gösteriminin \\((1010001)\\) olduğunu, yani, \\((81)_{10} = (1010001)_2\\) olduğunu gösteriniz. Ayrıca \\(0.10\\)’in ikili gösterimini bulunuz. "],["1.3-R-nesne.html", "1.3 R’da Nesneler", " 1.3 R’da Nesneler R nesneler (objects) üzerinden çalışır. Büyük-küçük harf ayırımı yapar, yani x ve X farklı nesnelerdir. Bir nesnenin içeriği = ya da &lt;- ile belirlenebilir. Örneğin: x &lt;- 5 y &lt;- 2 z &lt;- x^y z ## [1] 25 Hafızadaki tüm nesneleri görmek için ls() ## [1] &quot;a&quot; &quot;b&quot; &quot;e&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; # ya da objects() RStudio’da sağ üst pencerede Environment altında tüm nesneler görülebilir. rm(x) komutu x nesnesini hafızadan siler. Tüm nesneleri silmek istersek rm(list=ls()) ls() Nesne isimleri rakamla başlayamaz, virgül ve boşluk içeremez (nokta içerebilir). Komut satırında aşagıdaki işlemleri yapınız: 2nesne &lt;- c(10, 20) nesne2 &lt;- c(10, 20) nesne2 ## [1] 10 20 Nesnelerin isimlendirilmesinde yaygın kullanılan örnekler: # Örnek 1 yeni_bir_nesne &lt;- nesne2*5 yeni_bir_nesne ## [1] 50 100 # Örnek 2 YeniBirNesne &lt;- nesne2*5 YeniBirNesne ## [1] 50 100 # Örnek 3 yeni.bir.nesne &lt;- nesne2^3 yeni.bir.nesne ## [1] 1000 8000 Temel nesne türleri Vektör: nümerik, karakter, mantıksal, tamsayı Matris Liste Veri çerçevesi (data frame) class(yeni_bir_nesne) ## [1] &quot;numeric&quot; typeof(yeni_bir_nesne) ## [1] &quot;double&quot; "],["1.4-R-vektor.html", "1.4 Vektörler", " 1.4 Vektörler Bir R vektörü (ya da bir atomik vektör) bir değer ya da bilgi topluluğudur. Sayısal ya da sayısal olmayan elemanlar içerebilir. Ancak sadece bir türde değer içerebilir: reel sayılar (doubles), tamsayılar (integers), karakterler (characters), mantıksal (logicals) ve kompleks sayılar. 5 öğeli sıfırlar vektörü: sifirlar &lt;- numeric(5) sifirlar ## [1] 0 0 0 0 0 Tüm öğeleri yanlış olan mantıksal vektör: mantiksal &lt;- logical(5) mantiksal ## [1] FALSE FALSE FALSE FALSE FALSE R’da TRUE ve FALSE yerleşik isimlerdir, kullanıcılar tarafından değiştirilemez. Boş karakter vektörü: kar &lt;- character(5) kar ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Bir R vektörü çeşitli biçimlerde oluşturulabilir. Örneğin, aşağıdaki örnekte olduğu gibi c() fonksiyonuyla a ve b vektörlerini oluşturabiliriz: a &lt;- c(1,2,3,4,5) a ## [1] 1 2 3 4 5 b &lt;- c(1,1,1,1,1) a+b ## [1] 2 3 4 5 6 Vektör öğelerine isim verilebilir: puanlar &lt;- c(&quot;Ahmet&quot; = 80, &quot;Burcu&quot; = 95, &quot;Hasan&quot; = 67) print(puanlar) ## Ahmet Burcu Hasan ## 80 95 67 names(puanlar) ## [1] &quot;Ahmet&quot; &quot;Burcu&quot; &quot;Hasan&quot; Tamsayı vektörü tam &lt;- c(10L, 20L) typeof(a) ## [1] &quot;double&quot; typeof(tam) ## [1] &quot;integer&quot; Karakter vektörü karakter &lt;- c(&quot;iyi&quot;, &quot;orta&quot;, &quot;kötü&quot;) karakter ## [1] &quot;iyi&quot; &quot;orta&quot; &quot;kötü&quot; typeof(karakter) ## [1] &quot;character&quot; Örnek: skor vektörü bir ürün için 100 üzerinden değerlendirmeleri göstersin: skor &lt;- c(&quot;Denek 1&quot; = 80, &quot;Denek 2&quot; = 65, &quot;Denek 3&quot; = 78, &quot;Denek 4&quot; = 94, &quot;Denek 5&quot; = 100, &quot;Denek 6&quot; = NA, &quot;Denek 7&quot; = 55, &quot;Denek 8&quot; = 85, &quot;Denek 9&quot; = 88, &quot;Denek 10&quot; = 75) print(skor) ## Denek 1 Denek 2 Denek 3 Denek 4 Denek 5 Denek 6 Denek 7 Denek 8 Denek 9 ## 80 65 78 94 100 NA 55 85 88 ## Denek 10 ## 75 Yaygın kullanılan vektör fonksiyonları: # vektörün eleman sayısı length(a) # ya da NROW(a) ## [1] 5 # sırala sort(skor) # default: küçükten büyüğe, NA hariç ## Denek 7 Denek 2 Denek 10 Denek 3 Denek 1 Denek 8 Denek 9 Denek 4 Denek 5 ## 55 65 75 78 80 85 88 94 100 # maximum max(a) ## [1] 5 # minimum min(a) ## [1] 1 # elemanların toplamı sum(a) ## [1] 15 # elemanların çarpımı prod(a) ## [1] 120 # Tüm elemanları a olan n-vektör: rep(a, n) rep(1,10) ## [1] 1 1 1 1 1 1 1 1 1 1 # seq(T): 1&#39;den T&#39;ye tamsayı dizisi seq(10) ## [1] 1 2 3 4 5 6 7 8 9 10 # seq(t,T) t&#39;den T&#39;ye tamsayı dizisi seq(5,10) ## [1] 5 6 7 8 9 10 # seq(t,T,s) t&#39;den T&#39;ye s artışla tamsayı dizisi seq(1,10,2) ## [1] 1 3 5 7 9 Bir vektörün elemanlarına ulaşmak için [ ] ile pozisyonu bildirmemiz gerekir: # 1nci eleman skor[1] ## Denek 1 ## 80 # ilk 3 eleman skor[1:3] ## Denek 1 Denek 2 Denek 3 ## 80 65 78 # son eleman n &lt;- length(skor) skor[n] ## Denek 10 ## 75 # son 3 eleman skor[(n-3):n] ## Denek 7 Denek 8 Denek 9 Denek 10 ## 55 85 88 75 Alıştırma skor[(n-3):n] yerine skor[n-3:n] kullanınız. Sonucu tartışınız. skor[n-3:n] ## Denek 7 Denek 6 Denek 5 Denek 4 Denek 3 Denek 2 Denek 1 ## 55 NA 100 94 78 65 80 "],["1.5-R-log-vek.html", "1.5 Mantıksal vektörler", " 1.5 Mantıksal vektörler Yukarıda belirttiğimiz gibi, TRUE ve FALSE rezerve kelimelerdir. # mantıksal işlemler, ==, !=, &gt;, &lt;, &gt;=, &lt;= 0 == 0 ## [1] TRUE 0 == 1 ## [1] FALSE print(a) ## [1] 1 2 3 4 5 # 2&#39;den büyük sayılar a &gt;= 3 ## [1] FALSE FALSE TRUE TRUE TRUE Arka planda bu kelimelerin karşılığı nümerik olarak TRUE (T) için 1 FALSE (F) için 0’dır. Örneğin, logic1 &lt;- c(TRUE, FALSE, TRUE) as.numeric(logic1) ## [1] 1 0 1 Mantıksal vektörlerle aritmetik işlem yapılırken dikkat edilmeli. # parantez içinde mantıksal karşılaştırma: 1-(a&lt;=3) ## [1] 0 0 0 1 1 Mantıksal işlemciler, ==, &gt;, &lt;, &gt;=, &lt;= ,!=, kullanarak yeni vektörler oluşturabiliriz. Örneğin, dusuk_skorlar &lt;- (skor &lt; 70) dusuk_skorlar ## Denek 1 Denek 2 Denek 3 Denek 4 Denek 5 Denek 6 Denek 7 Denek 8 Denek 9 ## FALSE TRUE FALSE FALSE FALSE NA TRUE FALSE FALSE ## Denek 10 ## FALSE Değerlendirme notu 70’den küçük olanları bulmak istersek mantıksal ifadeleri vektör elemanlarına ulaşmakta kullanabiliriz (logical subscripting). Yukarıda oluşturduğumuz mantıksal vektörden hareketle: skor ## Denek 1 Denek 2 Denek 3 Denek 4 Denek 5 Denek 6 Denek 7 Denek 8 Denek 9 ## 80 65 78 94 100 NA 55 85 88 ## Denek 10 ## 75 skor[dusuk_skorlar] ## Denek 2 &lt;NA&gt; Denek 7 ## 65 NA 55 Alıştırma skor vektöründe kayıp değerleri NA bulunuz ve yeni bir vektör yaratarak bu değerleri siliniz. Çözüm Bunun en basit yolu temel R’da yer alan which() ve is.na() fonksiyonlarını kullanmaktır. is.na() fonksiyonu NA elemanlar için mantıksal değer TRUE olmayanlar için FALSE değerini içeren bir mantıksal vektör oluşturur. # öğe NA mı ? is.na(skor) ## Denek 1 Denek 2 Denek 3 Denek 4 Denek 5 Denek 6 Denek 7 Denek 8 Denek 9 ## FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE ## Denek 10 ## FALSE which() ise NA olan elemanların pozisyonunu (indeks bilgisini) verir. # NA&#39;nın konumunu bul which(is.na(skor)) ## Denek 6 ## 6 Ya da NA olmayan elemanların indeks bilgisini oluşturmak istersek: # sayısal öğelerin konumu which(!is.na(skor)) ## Denek 1 Denek 2 Denek 3 Denek 4 Denek 5 Denek 7 Denek 8 Denek 9 Denek 10 ## 1 2 3 4 5 7 8 9 10 Burada !is.na() kayıp olmayan elemanları seçer (! olumsuzlama operatörüdür). Şimdi NA olan elemanı dışlayıp yeni bir vektör içinde kaydedelim: skor2 &lt;- skor[which(!is.na(skor))] skor2 ## Denek 1 Denek 2 Denek 3 Denek 4 Denek 5 Denek 7 Denek 8 Denek 9 Denek 10 ## 80 65 78 94 100 55 85 88 75 Aslında which() bu örnekte gereksizdir (ara adımları istemiyorsak): skor2 &lt;- skor[!is.na(skor)] skor2 ## Denek 1 Denek 2 Denek 3 Denek 4 Denek 5 Denek 7 Denek 8 Denek 9 Denek 10 ## 80 65 78 94 100 55 85 88 75 Kayıp gözlemleri silmek için tasarlanmış olan na.omit() fonksiyonu da kullanılabilir. "],["1.6-R-matris.html", "1.6 Matrisler", " 1.6 Matrisler R’da matris oluşturmanın en kolay yolu matrix() fonksiyonudur. Örneğin, skor vektöründen hareketle \\(10\\times 1\\) matris oluşturalım: A &lt;- matrix(data = skor, nrow=10, ncol=1, byrow = FALSE, dimnames = NULL) print(A) ## [,1] ## [1,] 80 ## [2,] 65 ## [3,] 78 ## [4,] 94 ## [5,] 100 ## [6,] NA ## [7,] 55 ## [8,] 85 ## [9,] 88 ## [10,] 75 dim(A) # matrisin boyutları satır x sütun ## [1] 10 1 İstersek satır ve sütunları isimlendirebiliriz: rownames(A) &lt;- names(skor) colnames(A) &lt;- &quot;skor&quot; print(A) ## skor ## Denek 1 80 ## Denek 2 65 ## Denek 3 78 ## Denek 4 94 ## Denek 5 100 ## Denek 6 NA ## Denek 7 55 ## Denek 8 85 ## Denek 9 88 ## Denek 10 75 Matrisin boyutlarını değiştirebiliriz: B &lt;- matrix(data=1:10, nrow=5, ncol=2, byrow=FALSE, dimnames=NULL) print(B) ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 BB &lt;- matrix(data=1:10, nrow=5, ncol=2, byrow=TRUE, dimnames=NULL) print(BB) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 ## [4,] 7 8 ## [5,] 9 10 t() fonksiyonu ile matrisin devriği (transpose) bulunabilir: t(B) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 Matrislerle mantıksal işlemler yapılabilir: B &gt; 5 ## [,1] [,2] ## [1,] FALSE TRUE ## [2,] FALSE TRUE ## [3,] FALSE TRUE ## [4,] FALSE TRUE ## [5,] FALSE TRUE which(B&gt;5) ## [1] 6 7 8 9 10 BB &gt; 5 ## [,1] [,2] ## [1,] FALSE FALSE ## [2,] FALSE FALSE ## [3,] FALSE TRUE ## [4,] TRUE TRUE ## [5,] TRUE TRUE which(BB&gt;5) ## [1] 4 5 8 9 10 Pozisyonun sütun bazında belirlendiğine (yani matris sütun bazında vektörize edilse) dikkat ediniz. Boş (sıfırlar) matrisi zeros &lt;- matrix(data = 0, nrow = 5, ncol = 5) zeros ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 0 0 0 ## [2,] 0 0 0 0 0 ## [3,] 0 0 0 0 0 ## [4,] 0 0 0 0 0 ## [5,] 0 0 0 0 0 Matris oluşturmanın başka bir yolu da mevcut vektörlerin birleştirilmesidir. Bunun için cbind ve rbind kullanılabilir. Örneğin, x &lt;- cbind(b,a) x ## b a ## [1,] 1 1 ## [2,] 1 2 ## [3,] 1 3 ## [4,] 1 4 ## [5,] 1 5 # cbind(1,1:5) ## [,1] [,2] ## [1,] 1 1 ## [2,] 1 2 ## [3,] 1 3 ## [4,] 1 4 ## [5,] 1 5 Bireylerin cinsiyetini içeren bir karakter vektörü oluşturalım: cinsiyet &lt;- c(&quot;Kadın&quot;, &quot;Erkek&quot;, &quot;Kadın&quot;, &quot;Kadın&quot;, &quot;Erkek&quot;, &quot;Kadın&quot;, &quot;Erkek&quot;, &quot;Erkek&quot;, &quot;Kadın&quot;, &quot;Kadın&quot;) print(cinsiyet) ## [1] &quot;Kadın&quot; &quot;Erkek&quot; &quot;Kadın&quot; &quot;Kadın&quot; &quot;Erkek&quot; &quot;Kadın&quot; &quot;Erkek&quot; &quot;Erkek&quot; &quot;Kadın&quot; &quot;Kadın&quot; table(cinsiyet) ## cinsiyet ## Erkek Kadın ## 4 6 Burada cinsiyet bir kategorik (ya da kesikli) değişkendir. Şimdi skor ve cinsiyet bilgisini bir araya getirelim ve buna x ismini verelim: x&lt;- cbind(skor, cinsiyet) x ## skor cinsiyet ## Denek 1 &quot;80&quot; &quot;Kadın&quot; ## Denek 2 &quot;65&quot; &quot;Erkek&quot; ## Denek 3 &quot;78&quot; &quot;Kadın&quot; ## Denek 4 &quot;94&quot; &quot;Kadın&quot; ## Denek 5 &quot;100&quot; &quot;Erkek&quot; ## Denek 6 NA &quot;Kadın&quot; ## Denek 7 &quot;55&quot; &quot;Erkek&quot; ## Denek 8 &quot;85&quot; &quot;Erkek&quot; ## Denek 9 &quot;88&quot; &quot;Kadın&quot; ## Denek 10 &quot;75&quot; &quot;Kadın&quot; Yukarıda x’in tüm elemanları karakter tipine zorlandı. Bunun nedeni R’da vektör ve matrislerin sadece tek tip (sayısal, karakter, mantıksal, vs.) değere sahip olabilmesidir. "],["1.7-R-liste.html", "1.7 Listeler", " 1.7 Listeler Bir R listesi farklı türlerde, uzunluk ve boyutlarda nesneleri içerebilen bir nesneler topluluğudur. # bir R listesi oluştur liste1 &lt;- list(numaralar = seq(10,20,3), isimler = c(&quot;Ahmet&quot;, &quot;Burcu&quot;, &quot;Hasan&quot;), birim_mat = diag(4) ) # liste1 ## $numaralar ## [1] 10 13 16 19 ## ## $isimler ## [1] &quot;Ahmet&quot; &quot;Burcu&quot; &quot;Hasan&quot; ## ## $birim_mat ## [,1] [,2] [,3] [,4] ## [1,] 1 0 0 0 ## [2,] 0 1 0 0 ## [3,] 0 0 1 0 ## [4,] 0 0 0 1 Liste içindeki nesnelerin isimleri için names() komutu kullanılabilir: names(liste1) ## [1] &quot;numaralar&quot; &quot;isimler&quot; &quot;birim_mat&quot; Bir listenin belirli bir bileşenine liste_ismi$bilesen_ismi ile ulaşılabilir. # örnek liste1$numaralar ## [1] 10 13 16 19 liste1$numaralar[1] ## [1] 10 dim(liste1$birim_mat) ## [1] 4 4 "],["1.8-R-data-fr.html", "1.8 Veri Çerçeveleri (Data Frames)", " 1.8 Veri Çerçeveleri (Data Frames) R’da en temel nesnelerden biri veri çerçevesi (data frame)’dir. Belirli özelliklere sahip bir liste olarak düşünülebilir. Aynı uzunlukta ve farklı tipte vektörleri bir araya getirmemize olanak tanır. Örneğin veri1 &lt;- data.frame(skor, cinsiyet) veri1 ## skor cinsiyet ## Denek 1 80 Kadın ## Denek 2 65 Erkek ## Denek 3 78 Kadın ## Denek 4 94 Kadın ## Denek 5 100 Erkek ## Denek 6 NA Kadın ## Denek 7 55 Erkek ## Denek 8 85 Erkek ## Denek 9 88 Kadın ## Denek 10 75 Kadın names(veri1) ## [1] &quot;skor&quot; &quot;cinsiyet&quot; str(veri1) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ skor : num 80 65 78 94 100 NA 55 85 88 75 ## $ cinsiyet: chr &quot;Kadın&quot; &quot;Erkek&quot; &quot;Kadın&quot; &quot;Kadın&quot; ... summary(veri1) ## skor cinsiyet ## Min. : 55 Length:10 ## 1st Qu.: 75 Class :character ## Median : 80 Mode :character ## Mean : 80 ## 3rd Qu.: 88 ## Max. :100 ## NA&#39;s :1 # örnek veri seti simülasyonu set.seed(123) x1 = rnorm(100, mean=5, sd=1.2) x2 = rnorm(100, mean=0, sd=0.8) grup = sample(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 100, replace = TRUE) y = 2 + 2*x1 - 3*x2 + 5*(grup==&quot;B&quot;) + 8*(grup==&quot;C&quot;) + rnorm(100) # veri2 &lt;- data.frame(y, x1, x2, grup) # veri çerçevesini oluştur head(veri2) ## y x1 x2 grup ## 1 18.60331 4.327429 -0.56832525 C ## 2 18.44227 4.723787 0.20550697 C ## 3 24.42217 6.870450 -0.19735350 C ## 4 13.84834 5.084610 -0.27803408 A ## 5 15.55670 5.155145 -0.76129485 A ## 6 24.90853 7.058078 -0.03602218 C "],["1.9-R-gorsel.html", "1.9 Görselleştirme", " 1.9 Görselleştirme 1.9.1 Plot fonksiyonu plot(x, y) iki nümerik vektör girdisini kullanarak serpilme çizimini oluşturur. örnek: plot(veri2$x1, veri2$y) plot(veri2$x2, veri2$y) 1.9.2 Eğri çizimi Temel R’da bunun için curve() kullanılabilir. Yardım dosyasına ulaşmak için ?curve. Örnekler: # a linear function curve(1+2*x, from=-2, to=2, xlab=&quot;x&quot;, ylab=&quot;&quot; ) # add a quadratic function curve(1+2*x-2*x^2, add = TRUE, col = &quot;red&quot; ) # cubic curve(1+2*x-2*x^2+3*x^3, add = TRUE, col = &quot;blue&quot; ) Kendi cebirsel fonksiyonlarımızı function() ile oluşturup curve() ya da plot() yardımıyla çizebiliriz: # fonksiyonu tanımla fun1 &lt;- function(x) 2*sin(x)+cos(x) # eğriyi çiz curve(fun1, -pi, pi, n = 100) # focus on the interval -2 &lt; x &lt; 2 plot(fun1, -2, 2) 1.9.3 Histogram Sürekli değerler alan bir nümerik vektörün histogramı için hist() fonksiyonu kullanılabilir: hist(veri2$x1) Düzleştirilmiş histogram: hist(veri2$x1, freq = FALSE, ylim = c(0, 0.4), xlim = c(0,10), xlab = &quot;x1&quot;, main = &quot;Histogram&quot;) lines(density(veri2$x1)) Temel R grafiklerine bir çok alternatif mevcuttur. Bunlardan en önemlisi ggplot2 paketidir. Bu paketin özelliklerini daha sonra inceleyeceğiz. 1.9.4 Kutu çizimi Kutu çizimi için boxplot() fonksiyonu kullanılabilir: boxplot(veri2$x1, horizontal=TRUE) Tukey’nin 5-sayı özeti ile birlikte yorumlanmalıdır: # min Q1 median Q3 max fivenum(veri2$x1) ## [1] 2.228997 4.403987 5.074108 5.833998 7.624800 summary(veri2$x1) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2.229 4.407 5.074 5.108 5.830 7.625 Kategorik değişkene göre kutu çizimleri: boxplot(veri2$y ~ veri2$grup, horizontal=FALSE) Başka bir yol: plot(as.factor(veri2$grup), veri2$y) 1.9.5 Örneklem birikimli yoğunluk fonksiyonu ECDF (empirical cumulative density function) belirli bir değerden daha küçük gözlemlerin oranını verir. Bunun grafiğini çizmek için plot(ecdf()) kullanılabilir. Örneğin, plot(ecdf(veri2$x1)) 1.9.6 Serpilme çizimi Örnek: plot(veri2$x2, veri2$y, col = rgb(0,100,0,50, maxColorValue = 255), # renk kontrolü pch = 16, # nokta şekli main =&quot;Serpilme çizimi&quot;, # başlık xlab = &quot;x1&quot;, ylab = &quot;y&quot; ) Detaylar için bkz. ?par, ?points, ?rgb. 1.9.7 Kategorik değişkenler Kategorik değişkenlerin frekans dağılımlarının oluşturulmasında table() ve prop.table(table()) fonksiyonları kullanılabilir: table(veri2$grup) ## ## A B C ## 33 35 32 prop.table(table(veri2$grup)) ## ## A B C ## 0.33 0.35 0.32 R’da kategorik değişkenlere verilen bir başka isim faktör değişkenleridir. Bunları aşağıdaki gibi tanımlayabiliriz: ## etiketleri oluştur grup_etiket &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) # faktor değişkeni oluştur grup_faktor &lt;- factor(veri2$grup, labels = grup_etiket) # sıklık dağılımı table(grup_faktor) ## grup_faktor ## A B C ## 33 35 32 Çubuk çizimi (bar plot) barplot(table(grup_faktor)) Pasta grafiği # pie(table(grup_faktor), col = blues9) "],["1.10-R-prog.html", "1.10 Temel Programlama", " 1.10 Temel Programlama 1.10.1 Mantıksal işlemler Ve işlemcisi: &amp; # doğru ve doğru = doğru TRUE &amp; TRUE ## [1] TRUE # doğru ve yanlış = yanlış TRUE &amp; FALSE ## [1] FALSE # yanlış ve doğru = yanlış FALSE &amp; TRUE ## [1] FALSE # yanlış ve yanlış = yanlış FALSE &amp; FALSE ## [1] FALSE x &lt;- c(4, 8) x &gt; 3 &amp; x &lt; 6 ## [1] TRUE FALSE Veya işlemcisi: | # doğru veya doğru = doğru TRUE | TRUE ## [1] TRUE # doğru veya yanlış = doğru TRUE | FALSE ## [1] TRUE # yanlış veya doğru = doğru FALSE | TRUE ## [1] TRUE # yanlış veya yanlış = yanlış FALSE | FALSE ## [1] FALSE x &lt;- c(4, 8) x &gt; 3 | x &lt; 6 ## [1] TRUE TRUE !(X &amp; Y) ile !X | !Y aynı sonucu verir. !(X | Y) ile !X &amp; !Y aynı sonucu verir. Mantıksal işlemleri kullanarak bir veri çerçevesinin satırları (gözlemler) seçilebilir: # grup = A olanları seç veri2_A &lt;- veri2[grup == &quot;A&quot;, ] head(veri2_A) ## y x1 x2 grup ## 4 13.848335 5.084610 -0.27803408 A ## 5 15.556703 5.155145 -0.76129485 A ## 10 8.899622 4.465206 0.73519729 A ## 14 10.731512 5.132819 -0.04444957 A ## 15 10.155900 4.332991 0.41552576 A ## 16 15.951850 7.144296 0.24092269 A # subset() fonksiyonu ile head(subset(veri2, grup==&quot;A&quot;)) ## y x1 x2 grup ## 4 13.848335 5.084610 -0.27803408 A ## 5 15.556703 5.155145 -0.76129485 A ## 10 8.899622 4.465206 0.73519729 A ## 14 10.731512 5.132819 -0.04444957 A ## 15 10.155900 4.332991 0.41552576 A ## 16 15.951850 7.144296 0.24092269 A # grup = A ve grup = B olanları seç veri2_AB &lt;- veri2[grup == &quot;A&quot; | grup == &quot;B&quot;, ] head(veri2_AB) ## y x1 x2 grup ## 4 13.848335 5.084610 -0.2780341 A ## 5 15.556703 5.155145 -0.7612949 A ## 7 18.594695 5.553099 -0.6279236 B ## 9 15.817540 4.175777 -0.3041812 B ## 10 8.899622 4.465206 0.7351973 A ## 11 21.393180 6.468898 -0.4602776 B # %in% işlemcisi ile # grup = A ve grup = B olanları seç veri2_AB &lt;- veri2[grup %in% c(&quot;A&quot;, &quot;B&quot;), ] head(veri2_AB) ## y x1 x2 grup ## 4 13.848335 5.084610 -0.2780341 A ## 5 15.556703 5.155145 -0.7612949 A ## 7 18.594695 5.553099 -0.6279236 B ## 9 15.817540 4.175777 -0.3041812 B ## 10 8.899622 4.465206 0.7351973 A ## 11 21.393180 6.468898 -0.4602776 B Veri çerçevesinden rassal olarak bazı gözlemlerin seçilmesi: # veri2&#39;den 10 satırın rassal seçimi set.seed(99) orneklem1 &lt;- sample(1:nrow(veri2), 10, replace = FALSE) orneklem1 # satır numaraları ## [1] 48 33 44 22 62 32 13 20 31 68 # veri2&#39;den satırları çek veri2[orneklem1, ] ## y x1 x2 grup ## 48 8.876980 4.440014 0.55033342 A ## 33 23.299257 6.074151 0.03298634 C ## 44 22.141873 7.602747 -1.21173412 A ## 22 13.531749 4.738430 -0.75797969 A ## 62 14.647966 4.397212 -0.83934161 A ## 32 15.229202 4.645914 0.36120324 B ## 13 21.869445 5.480926 -1.29430617 B ## 20 13.544229 4.432650 -0.81930303 A ## 31 8.205689 5.511757 1.15564069 A ## 68 18.665672 5.063605 -0.38702450 B Benzer şekilde bir veri setinden bootstrap örneklemleri oluşturulabilir: satirno &lt;- sample(1:nrow(veri2), nrow(veri2), replace = TRUE) boot1 &lt;- veri2[satirno, ] head(boot1) ## y x1 x2 grup ## 9 15.81754 4.175777 -0.30418122 B ## 82 16.91902 5.462336 1.01054814 C ## 88 19.94786 5.522218 0.06778983 C ## 30 22.04715 6.504578 -0.05704647 B ## 86 12.84222 5.398138 -0.15774072 A ## 84 24.63868 5.773252 -0.69241029 C 1.10.2 Koşullu işlem Koşullu işlemleri if else komutlarını kullanarak yapabiliriz. Kullanım örneği: if (condition) { .... } else { .... } Nümerik örnek: a &lt;- seq(1,10,1) b &lt;- 85 c &lt;- &quot;YTU&quot; if (typeof(b)==&quot;double&quot; | typeof(b)==&quot;integer&quot;) { print(b) } else { print(&quot;This is not a numeric object&quot;) } ## [1] 85 x &lt;- -10 if (x &lt; 0) { print(&quot;x negatif bir sayıdır&quot;) } else if (x == 0) { print(&quot;x sıfıra eşittir&quot;) } else { print(&quot;x pozitif bir sayıdır&quot;) } ## [1] &quot;x negatif bir sayıdır&quot; 1.10.3 Döngüler Döngü içinde işlem yapmak için for komutunu kullanabiliriz. Kullanım şablonu: for (dongu_degiskeni in vektor) { } Burada dongu_degiskeni sırasıyla vektor içindeki değerleri almaktadır. Örneğin, for (i in 1:5) { print(i) } Nümerik örnek: for (i in 1:10){ if (i&lt;5) {print(i^2)} else {print(sqrt(i))} } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 ## [1] 2.236068 ## [1] 2.44949 ## [1] 2.645751 ## [1] 2.828427 ## [1] 3 ## [1] 3.162278 Döngüler üç şekilde oluşturulabilir: öğeler üzerinde: for (x in A) nümerik konum üzerinde: for (i in seq_along(A)) isimler üzerinde: for (nm in names(A)) Döngüleri hızlandırmanın bir yolu nümerik indisler üzerinde döngüyü çalıştırmak ve ve döngüden önce çıktı için boş bir nesne oluşturmaktır: sonuc &lt;- numeric(length(A)) for (i in seq_along(A)) { sonuc[i] &lt;- sqrt(A[i]) } 1.10.4 Fonksiyonel İşlemler lapply() bir liste ya da vektörün tüm elemanlarına bir fonksiyonu uygular ve aynı uzunlukta bir çıktı içinde saklar. Böylece işlemleri döngü içinde yapmaya gerek kalmayabilir. Örnek: mtcars veri setindeki değişkenlerin aritmetik ortalamalarını bulunuz. Bir data frame aynı zamanda bir liste olduğundan lapply() kullanılabilir: liste_ort &lt;- lapply(mtcars, mean) # unlist(liste_ort) ## mpg cyl disp hp drat wt qsec vs ## 20.090625 6.187500 230.721875 146.687500 3.596563 3.217250 17.848750 0.437500 ## am gear carb ## 0.406250 3.687500 2.812500 lapply() içinde kendi yazdığımız fonksiyonları da kullanabiliriz. Örnek: bir veri çerçevesinin sütunlarındaki kayıp gözlemleri (NA) sayınız. Veri setimiz aşağıdaki gibi olsun: set.seed(456) x1 &lt;- runif(100) x2 &lt;- runif(100) x3 &lt;- rnorm(100) x4 &lt;- rnorm(100) napoz1 &lt;- sample(1:100, sample(1:10, 1), replace = FALSE) napoz2 &lt;- sample(1:100, sample(1:10, 1), replace = FALSE) x1[napoz1] &lt;- NA x2[napoz2] &lt;- NA data &lt;- data.frame(x1, x2, x3, x4) head(data) ## x1 x2 x3 x4 ## 1 0.0895516 0.2530410 0.11815133 0.293886215 ## 2 0.2105123 0.1337840 0.86990262 1.052402224 ## 3 0.7329553 0.3987728 -0.09193621 -0.006435601 ## 4 0.8521335 0.2829084 0.06889879 -0.404523473 ## 5 0.7883979 0.7513620 -1.68242675 -0.080917045 ## 6 0.3319600 0.8058037 1.11695555 -1.072424293 na_sayisi &lt;- function(x) { sum(is.na(x)) } unlist(lapply(data, na_sayisi)) ## x1 x2 x3 x4 ## 8 4 0 0 # ya da daha basit olarak unlist(lapply(data, function(x) sum(is.na(x)))) ## x1 x2 x3 x4 ## 8 4 0 0 sapply() ve vapply() fonksiyonelleri lapply() gibi çalışır. Ancak çıktı olarak atomik vektör oluştururlar # data sütunları nümerik mi? sapply(data, is.numeric) ## x1 x2 x3 x4 ## TRUE TRUE TRUE TRUE # data sütunlarında NA sayısı sapply(data, function(x) sum(is.na(x))) ## x1 x2 x3 x4 ## 8 4 0 0 # vapply() için çıktı vektörünün türünü bildirmemiz gerekir vapply(data, is.numeric, logical(1)) ## x1 x2 x3 x4 ## TRUE TRUE TRUE TRUE # data sütunlarında NA sayısı vapply(data, function(x) sum(is.na(x)), numeric(1)) ## x1 x2 x3 x4 ## 8 4 0 0 sapply() interaktif uygulamalarda vapply() ise programlamada önerilir. Matris veya çok boyutlu diziler için apply() kullanılabilir: # 200 x 5 boyutlu bir uniform matris oluştur set.seed(789) X &lt;- matrix(runif(1000), ncol = 5) colnames(X) &lt;- letters[1:5] head(X) ## a b c d e ## [1,] 0.69989436 0.29265239 0.0007847089 0.1423423 0.85313937 ## [2,] 0.09349887 0.09354572 0.5411858680 0.9821530 0.05266862 ## [3,] 0.01188682 0.34495804 0.0488849813 0.1806375 0.67594448 ## [4,] 0.59160635 0.21537353 0.3234363657 0.9168293 0.45698617 ## [5,] 0.49214944 0.72085409 0.1213557085 0.8762951 0.30602751 ## [6,] 0.02016358 0.92697327 0.9060655029 0.9215866 0.31179128 # X&#39;in sütun ortalamalarını bul apply(X, 2, mean) # satırlar için margin=1, sütunlar için ise 2 ## a b c d e ## 0.4848826 0.5282805 0.5045356 0.4875399 0.5228984 "],["1.11-R-fonksiyon.html", "1.11 R Fonksiyonları", " 1.11 R Fonksiyonları R’da bütün işlemler fonksiyonlarla yapılır. Tipik bir R fonksiyonu girdiler (argümanlar) ve çıktılardan oluşur. Örneğin mean() fonksiyonu skor girdisiyle çalıştırılırsa : mean(skor) ## [1] NA Burada çıktının ortalama değil NA olması öğelerden birinin NA olmasından kaynaklanır. Kayıp gözlemleri dışlayalım: mean(skor, na.rm = TRUE) # ya da mean(skor, TRUE) ## [1] 80 Kullanıcı girmezse na.rm = FALSE değerini alır ve sonuç NA olur. Örneklem standart sapması: sd(skor, na.rm = TRUE) ## [1] 13.98213 Fonksiyonun girdilerini görmek için: args(sd) ## function (x, na.rm = FALSE) ## NULL Fonksiyonu ekrana yazdırmak için x sd ## function (x, na.rm = FALSE) ## sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), ## na.rm = na.rm)) ## &lt;bytecode: 0x000002867399ba70&gt; ## &lt;environment: namespace:stats&gt; Kendi fonksiyonlarımızı yazmak için function() fonksiyonunu kullanabiliriz. fonksiyon_ismi &lt;- function(girdi1, girdi2) { ... işlemler ... } Örnek: Bir sayının tek mi çift mi olduğunu bulan bir fonksiyon yazalım: tek_cift &lt;- function(x) { if (x == 0) { print(&quot;Girdiğiniz sayı sıfırdır!&quot;) } else if (x %% 2 == 0) { print(&quot;Çift sayı&quot;) } else { print(&quot;Tek sayı&quot;) } } # tek_cift() fonksiyonunu kullanabiliriz tek_cift(4) ## [1] &quot;Çift sayı&quot; tek_cift(5L) ## [1] &quot;Tek sayı&quot; Örnek: Türkçe bir harfin alfabede kaçıncı harf olduğunu ekrana yazan bir fonksiyon yazınız. kacinci_harf &lt;- function (harf) { harfler &lt;- c(letters[1:3], &quot;Ç&quot;, letters[4:7], &quot;ğ&quot;, letters[8], &quot;ı&quot;, letters[9:15], &quot;ö&quot;, letters[16], letters[18:19], &quot;ş&quot;, letters[20:21], &quot;ü&quot;, letters[c(22,25,26)]) HARFLER &lt;- c(LETTERS[1:3], &quot;Ç&quot;, LETTERS[4:7], &quot;Ğ&quot;, LETTERS[8], &quot;I&quot;, &quot;İ&quot;, LETTERS[10:15], &quot;Ö&quot;, LETTERS[16], LETTERS[18:19], &quot;Ş&quot;, LETTERS[20:21], &quot;Ü&quot;, LETTERS[c(22,25,26)]) if (length(which(harfler == harf)) == 0) { paste0(harf, &quot; alfabenin &quot;, which(HARFLER == harf), &quot;. harfidir&quot;) } else { paste0(harf, &quot; alfabenin &quot;, which(harfler == harf), &quot;. harfidir&quot;) } } kacinci_harf(&quot;h&quot;) ## [1] &quot;h alfabenin 10. harfidir&quot; kacinci_harf(&quot;İ&quot;) ## [1] &quot;İ alfabenin 12. harfidir&quot; kacinci_harf(&quot;Ş&quot;) ## [1] &quot;Ş alfabenin 23. harfidir&quot; "],["1.12-R-paket.html", "1.12 R Paketleri", " 1.12 R Paketleri R kurulumuyla gelen temel paketler: rownames(installed.packages(priority=&quot;base&quot;)) ## [1] &quot;base&quot; &quot;compiler&quot; &quot;datasets&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;grid&quot; &quot;methods&quot; ## [8] &quot;parallel&quot; &quot;splines&quot; &quot;stats&quot; &quot;stats4&quot; &quot;tcltk&quot; &quot;tools&quot; &quot;utils&quot; R programının güçlü yanlarından biri kullanıcılar tarafından yazılmış paketlerin yüklenmesiyle geliştirilebilmesidir. Örneğin, {corrplot} paketi korelasyon matrisini görselleştirir: install.packages(&quot;corrplot&quot;, repos=&#39;http://cran.us.r-project.org&#39;) Detaylar için bkz https://cran.r-project.org/web/packages/corrplot/index.html. Alternatif olarak aynı işlem RStudio menüsünden de yapılabilir: Tools&gt;InstallPackages ilgili pencerede “{corrplot}” paket ismini yazmamız gerekir. Paketi kullanabilmek için önce yüklememiz daha sonra ise aktif hale getirmemiz gerekir: library(corrplot) kor_matris &lt;- cor(mtcars) corrplot(kor_matris) Komut satırında ?corrplot yazarak yardım dosyasını inceleyebiliriz (detaylı dokümantasyon dosyaları için help(package = \"corrplot\") komutu kullanılabilir) . Korelasyon matrisini nümerik değerleri kullanarak da görselleştirebiliriz. Yardım dosyasında da görüleceği gibi method=\"number\" opsiyonu bu amaç için kullanılabilir: corrplot(kor_matris, method = &quot;number&quot;) Pakete ilişkin örnekleri çalıştırmak için komut satırında aşağıdaki kodu çalıştırınız: example(corrplot) Pakete ilişkin diğer bilgiler için packageDescription(\" \") komutu kullanılabilir: packageDescription(&quot;corrplot&quot;) ## Package: corrplot ## Type: Package ## Title: Visualization of a Correlation Matrix ## Version: 0.92 ## Date: 2021-11-11 ## Authors@R: c( person(&#39;Taiyun&#39;, &#39;Wei&#39;, email = &#39;weitaiyun@gmail.com&#39;, role = ## c(&#39;cre&#39;, &#39;aut&#39;)), person(&#39;Viliam&#39;, &#39;Simko&#39;, email = ## &#39;viliam.simko@gmail.com&#39;, role = &#39;aut&#39;), person(&#39;Michael&#39;, &#39;Levy&#39;, ## email = &#39;michael.levy@healthcatalyst.com&#39;, role = &#39;ctb&#39;), ## person(&#39;Yihui&#39;, &#39;Xie&#39;, email = &#39;xie@yihui.name&#39;, role = &#39;ctb&#39;), ## person(&#39;Yan&#39;, &#39;Jin&#39;, email = &#39;jyfeather@gmail.com&#39;, role = &#39;ctb&#39;), ## person(&#39;Jeff&#39;, &#39;Zemla&#39;, email = &#39;zemla@wisc.edu&#39;, role = &#39;ctb&#39;), ## person(&#39;Moritz&#39;, &#39;Freidank&#39;, email = &#39;freidankm@googlemail.com&#39;, role ## = &#39;ctb&#39;), person(&#39;Jun&#39;, &#39;Cai&#39;, email = ## &#39;cai-j12@mails.tsinghua.edu.cn&#39;, role = &#39;ctb&#39;), person(&#39;Tomas&#39;, ## &#39;Protivinsky&#39;, email = &#39;tomas.protivinsky@gmail.com&#39;, role = &#39;ctb&#39;) ) ## Maintainer: Taiyun Wei &lt;weitaiyun@gmail.com&gt; ## Suggests: seriation, knitr, RColorBrewer, rmarkdown, magrittr, prettydoc, ## testthat ## Description: Provides a visual exploratory tool on correlation matrix that ## supports automatic variable reordering to help detect hidden patterns ## among variables. ## License: MIT + file LICENSE ## URL: https://github.com/taiyun/corrplot ## BugReports: https://github.com/taiyun/corrplot/issues ## VignetteBuilder: knitr ## RoxygenNote: 7.1.1 ## NeedsCompilation: no ## Packaged: 2021-11-18 12:31:22 UTC; taiyun ## Author: Taiyun Wei [cre, aut], Viliam Simko [aut], Michael Levy [ctb], Yihui ## Xie [ctb], Yan Jin [ctb], Jeff Zemla [ctb], Moritz Freidank [ctb], Jun ## Cai [ctb], Tomas Protivinsky [ctb] ## Repository: CRAN ## Date/Publication: 2021-11-18 13:20:02 UTC ## Built: R 4.2.3; ; 2023-04-26 00:32:10 UTC; windows ## ## -- File: C:/Users/hntas/AppData/Local/R/win-library/4.2/corrplot/Meta/package.rds Birden fazla paketi yüklemek istersek: install.packages(&quot;corrplot&quot;, &quot;MASS&quot;) R varsayılan paket deposu CRAN (The Comprehensive R Archive Network) üzerinden bu iki paketi yüklemeye çalışır. CRAN deposu en popüler yollardan biri olsa da paket yüklemenin başka yolları da vardır. Örneğin, {devtools} paketi ile github üzerinden ya da yerel olarak paketler yüklenebilir. "],["1.13-R-dizin.html", "1.13 Çalışma dizini", " 1.13 Çalışma dizini getwd() komutu ile güncel dizini görebiliriz: getwd() Bunu değiştirmek istersek setwd(\"/tam/adres/\") komutunu kullanabiliriz. Dizin adresinde \\ yerine / kullanıldığına dikkat ediniz: setwd(&quot;C:/Users/Folder/Another-Folder/R-uygulama-1&quot;) Tipik olarak bu R dosyaları başka bilgisayarlarda çalışmaz. Her bilgisayarda bu adreslerin tekrar tanımlanması gerekebilir. Bu da hatalara davetiye çıkarır. RStudio’da R proje klasörü oluşturarak çalışma dizininin otomatik olarak algılanmasını sağlayabiliriz. Bir R projesi yardımıyla dosyaların başka bilgisayarlarda da çalışması mümkün olur. "],["1.14-r-ile-online-veri-indirme.html", "1.14 R ile Online Veri İndirme", " 1.14 R ile Online Veri İndirme R ile World Bank WDI, Eurostat, IMF vb. platformlardan çevrimiçi veri indirmek için çeşitli paketler geliştirilmiştir. Çevrimiçi veri indirme paketlerinin bir listesi ve kullanım örnekleri için bkz. https://github.com/htastan/R-veri-indirme "],["2-tidyRgiris.html", " 2 R Tidyverse", " 2 R Tidyverse Tidyverse modern veri analizi için geliştirilmiş R paketler topluluğuna verilen isimdir. Bu konuda temel kaynak Garret Grolemund ve Hadley Wickham tarafından yazılan R for Data Science kitabıdır. Bu kitabın birinci baskısının Türkçe çevirisi için bkz. https://tr.r4ds.hadley.nz/ Ayrıca diğer kaynaklar için bkz. Tidy Data (Hadley Wickham, 2014 JSS), ve Tidy data Vignette Tidyverse R Paketleri library(tidyverse) ## ── Attaching core tidyverse packages ───────────────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.1 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.2 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.2 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.1 ## ── Conflicts ─────────────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(tidyverse) komutu ile aşağıdaki R paketlerinin tamamı aktif hale gelir: {ggplot2}: verilerin görselleştirilmesi {dplyr}: verilerin işlenmesi {tidyr}: verilerin düzenli (“tidy”) hale getirilmesi {readr}: verilerin okunması {purrr}: fonksiyonel programlama {tibble}: veri çerçevesi (data.frame’in yeni yorumu) {stringr}: karakterlerin işlenmesi {forcats}: faktör değişkenlerinin işlenmesi Bu paketlerin yanı sıra Tidyverse yaklaşımıyla uyumla çok sayıda R paketi mevcuttur. "],["2.1-r-tidy-veri-çerçeveleri.html", "2.1 R “Tidy” veri çerçeveleri", " 2.1 R “Tidy” veri çerçeveleri Bir düzenli (tidy) veri seti standart dikdörtgensel yapıya sahiptir. Ancak sütunlar değişkenleri, satırlar ise gözlemleri göstermelidir. Her veri seti düzenli formatta olmayabilir. Veri analizinden önce düzenli hale getirilmesi gerekebilir. Düzenli (tidy) bir veri setinin yapısı (kaynak: [R for Data Science]https://r4ds.had.co.nz/tidy-data.html) Örnek olarak aşağıdaki veri setini düşünelim: library(gapminder) head(gapminder) ## # A tibble: 6 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. gapminder Tidyverse jargonunda bir tibble’dır. Tibble (ya da tbl_df) R veri çerçevesinin daha modern bir yorumu olarak düşünülebilir (detaylar için bkz https://tibble.tidyverse.org/). {tibble} paketindeki tibble::tibble() fonksiyonunu kullanarak bir tidy veri seti yaratabiliriz: tibble( x = 1:5, y = 1, z = x ^ 2 + y ) ## # A tibble: 5 × 3 ## x y z ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 2 ## 2 2 1 5 ## 3 3 1 10 ## 4 4 1 17 ## 5 5 1 26 Başka bir örnek: df &lt;- tibble( xvariable = runif(5), depvariable = 2+ 5*xvariable + rnorm(5) ) df ## # A tibble: 5 × 2 ## xvariable depvariable ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.460 5.61 ## 2 0.212 3.14 ## 3 0.161 1.43 ## 4 0.780 5.16 ## 5 0.611 5.30 Tıpkı temel R’daki data.frame fonksiyonunda olduğu gibi tibble içindeki değişkenlere çeşitli yollarla ulaşabiliriz: # extract by column name df$xvariable ## [1] 0.4601115 0.2120150 0.1611190 0.7796910 0.6109223 # extract by column name df[[&quot;xvariable&quot;]] ## [1] 0.4601115 0.2120150 0.1611190 0.7796910 0.6109223 # extract by column position df[[1]] ## [1] 0.4601115 0.2120150 0.1611190 0.7796910 0.6109223 "],["2.2-readr-paketi-ile-verilerin-okutulması.html", "2.2 {readr} Paketi ile Verilerin okutulması", " 2.2 {readr} Paketi ile Verilerin okutulması Tidyverse meta-paketindeki {readr} paketi verilerin okutulmasına ilişkin çeşitli fonksionlar içerir. read_ ile başlayan bu fonksiyonlar şunlardır: read_csv(): virgülle ayrılmış dosya (comma separated (CSV)) read_tsv(): tab ile ayrılmış read_delim(): ayrılmış (örneğin “;” ya d “|” ile ayrılmış) read_fwf(): sabit genişlikli dosya read_table(): sütunların boşluklarla ayrıldığı tablo şeklindeki dosyalar read_log(): web log dosyaları Örnek: veriler/trveri1.csv her ne kadar uzantısı csv olsa da sütunların noktalı virgülle ayrıldığı bir dosya. Bu nedenle read_delim() kullanılabilir. tr_veri &lt;- read_delim(&quot;veriler/trveri1.csv&quot;, delim = &quot;;&quot;) ## Rows: 12 Columns: 6 ## ── Column specification ───────────────────────────────────────────────────────────────── ## Delimiter: &quot;;&quot; ## chr (2): il, degisken ## dbl (4): plaka, y2005, y2010, y2015 ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. Fonksiyonun çıktısında hangi değişkenlerin karakter hangilerinin nümerik (double) olarak okunduğunu görebiliyoruz. tr_veri ## # A tibble: 12 × 6 ## il plaka degisken y2005 y2010 y2015 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 34 GDPpc 16749 26253 49773 ## 2 Istanbul 34 RGDPpc 13986 14384 18602. ## 3 Istanbul 34 GDPpc_USD 12428 17480 18343 ## 4 Istanbul 34 population 12000000 13100000 14500000 ## 5 Izmir 35 GDPpc 12011 18308 34261 ## 6 Izmir 35 RGDPpc 9922 10211. 12927. ## 7 Izmir 35 GDPpc_USD 8912 12190 12626 ## 8 Izmir 35 population 3626321 3908672 4140726 ## 9 Ankara 6 GDPpc 15392 23997 40679 ## 10 Ankara 6 RGDPpc 12910 13019. 15029. ## 11 Ankara 6 GDPpc_USD 11420 15978 14992 ## 12 Ankara 6 population 4252588 4711187 5210297 Aynı veri setinin tab ile ayrılmış text dosyası formu: tr_veri &lt;- read_tsv(&quot;veriler/trveri1.txt&quot;) ## Rows: 12 Columns: 6 ## ── Column specification ───────────────────────────────────────────────────────────────── ## Delimiter: &quot;\\t&quot; ## chr (2): il, degisken ## dbl (4): plaka, y2005, y2010, y2015 ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. tr_veri ## # A tibble: 12 × 6 ## il plaka degisken y2005 y2010 y2015 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 34 GDPpc 16749 26253 49773 ## 2 Istanbul 34 RGDPpc 13986 14384 18602. ## 3 Istanbul 34 GDPpc_USD 12428 17480 18343 ## 4 Istanbul 34 population 12000000 13100000 14500000 ## 5 Izmir 35 GDPpc 12011 18308 34261 ## 6 Izmir 35 RGDPpc 9922 10211. 12927. ## 7 Izmir 35 GDPpc_USD 8912 12190 12626 ## 8 Izmir 35 population 3626321 3908672 4140726 ## 9 Ankara 6 GDPpc 15392 23997 40679 ## 10 Ankara 6 RGDPpc 12910 13019. 15029. ## 11 Ankara 6 GDPpc_USD 11420 15978 14992 ## 12 Ankara 6 population 4252588 4711187 5210297 Bu veri seti düzenli bir yapıda değildir. Satırlarda değişkenler, sütunlarda ise yıllar yer almaktadır. Verileri {tidyr} paketindeki fonksiyonları kullanarak yeniden düzenleyebiliriz. Bunu daha sonra göreceğiz. Dosyada yer alan değişkenlerin türlerini de belirtmek mümkündür. Kullanım rehberindeki örneğe bakalım: mtcars &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;), col_types = cols( mpg = col_double(), cyl = col_integer(), disp = col_double(), hp = col_integer(), drat = col_double(), vs = col_integer(), wt = col_double(), qsec = col_double(), am = col_integer(), gear = col_integer(), carb = col_integer() ) ) str(mtcars) ## spc_tbl_ [32 × 11] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : int [1:32] 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num [1:32] 160 160 108 258 360 ... ## $ hp : int [1:32] 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num [1:32] 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num [1:32] 16.5 17 18.6 19.4 17 ... ## $ vs : int [1:32] 0 0 1 1 0 1 0 1 1 1 ... ## $ am : int [1:32] 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: int [1:32] 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: int [1:32] 4 4 1 1 2 1 4 2 2 4 ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. mpg = col_double(), ## .. cyl = col_integer(), ## .. disp = col_double(), ## .. hp = col_integer(), ## .. drat = col_double(), ## .. wt = col_double(), ## .. qsec = col_double(), ## .. vs = col_integer(), ## .. am = col_integer(), ## .. gear = col_integer(), ## .. carb = col_integer() ## .. ) ## - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; Excel dosyalarının okutulmasında {readxl} paketi kullanılabilir. Bunun için paketin ayrıca yüklenmesi gerekir. Örnek: library(readxl) tr_veri &lt;- read_xlsx(&quot;veriler/trveri1.xlsx&quot;) tr_veri ## # A tibble: 12 × 6 ## il plaka degisken y2005 y2010 y2015 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 34 GDPpc 16749 26253 49773 ## 2 Istanbul 34 RGDPpc 13986 14384 18602. ## 3 Istanbul 34 GDPpc_USD 12428 17480 18343 ## 4 Istanbul 34 population 12000000 13100000 14500000 ## 5 Izmir 35 GDPpc 12011 18308 34261 ## 6 Izmir 35 RGDPpc 9922. 10211. 12927. ## 7 Izmir 35 GDPpc_USD 8912 12190 12626 ## 8 Izmir 35 population 3626321 3908672 4140726 ## 9 Ankara 6 GDPpc 15392 23997 40679 ## 10 Ankara 6 RGDPpc 12910. 13019. 15029. ## 11 Ankara 6 GDPpc_USD 11420 15978 14992 ## 12 Ankara 6 population 4252588 4711187 5210297 Stata, SPSS, ve SAS veri dosyalarının da okutulması mümkündür. Bunun için {haven} paketinin yüklenmesi gerekir. Interaktif veri yüklemek için bkz. Environment -&gt; Import Dataset -&gt; From Stata, etc. "],["2.3-tidyr-paketi-ile-verilerin-düzenlenmesi.html", "2.3 {tidyr} Paketi ile Verilerin Düzenlenmesi", " 2.3 {tidyr} Paketi ile Verilerin Düzenlenmesi veriler çok çeşitli biçimlerde karşımıza çıkabilir. Bir örneğini yukarıda görmüştük. Veri düzenlemesine ilişkin çeşitli örnekler: # düzenli bir veri seti table1 ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 # satırlarda değişkenler var, yıl aynı ülke için tekrar ediyor table2 ## # A tibble: 12 × 4 ## country year type count ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 # değişken (rate) karakter vektörü olarak tanımlı # ayrıca iki rakamın oranı açıkça yazılmış table3 ## # A tibble: 6 × 3 ## country year rate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 # sütunlarda değişkenin (cases) yıl ölçümleri var table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 # sütunlarda değişkenin (population) yıl ölçümleri var table4b ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 Bu veri setlerini nasıl tidy formata dönüştürebiliriz? Tidy formatta aşağıdaki kurallara uyulması gerekmektedir: Her değişken kendi sütununda olmalıdır. Her gözlem kendi satırında olmalıdır. Her değer kendi hücresinde olmalıdır. Verilerin yeniden organize edilmesinde {tidyr} paketinde yer alan iki fonksiyon çok faydalı olabilir. pivot_longer(): verileri yeniden düzenleyerek uzun forma dönüştürür pivot_wider(): verileri yeniden düzenleyerek geniş forma dönüştürür. Örnek: table4a ve table4b verilerini uzun forma dönüştürelim: pivot_longer(table4a, cols = 2:3, names_to = &quot;year&quot;, values_to = &quot;cases&quot;) ## # A tibble: 6 × 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 pivot_longer(table4b, cols = 2:3, names_to = &quot;year&quot;, values_to = &quot;population&quot;) ## # A tibble: 6 × 3 ## country year population ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 19987071 ## 2 Afghanistan 2000 20595360 ## 3 Brazil 1999 172006362 ## 4 Brazil 2000 174504898 ## 5 China 1999 1272915272 ## 6 China 2000 1280428583 Örnek: table2 verilerini geniş forma dönüştürelim: pivot_wider(table2, names_from = &quot;type&quot;, values_from = &quot;count&quot;) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Örnek: tr_veri verisini düzenli hale getirelim: tr_veri ## # A tibble: 12 × 6 ## il plaka degisken y2005 y2010 y2015 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 34 GDPpc 16749 26253 49773 ## 2 Istanbul 34 RGDPpc 13986 14384 18602. ## 3 Istanbul 34 GDPpc_USD 12428 17480 18343 ## 4 Istanbul 34 population 12000000 13100000 14500000 ## 5 Izmir 35 GDPpc 12011 18308 34261 ## 6 Izmir 35 RGDPpc 9922. 10211. 12927. ## 7 Izmir 35 GDPpc_USD 8912 12190 12626 ## 8 Izmir 35 population 3626321 3908672 4140726 ## 9 Ankara 6 GDPpc 15392 23997 40679 ## 10 Ankara 6 RGDPpc 12910. 13019. 15029. ## 11 Ankara 6 GDPpc_USD 11420 15978 14992 ## 12 Ankara 6 population 4252588 4711187 5210297 pivot_longer(tr_veri, cols = c(`y2005`, `y2010`, `y2015`), names_to = &quot;yil&quot;, values_to = &quot;olcum&quot;) ## # A tibble: 36 × 5 ## il plaka degisken yil olcum ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Istanbul 34 GDPpc y2005 16749 ## 2 Istanbul 34 GDPpc y2010 26253 ## 3 Istanbul 34 GDPpc y2015 49773 ## 4 Istanbul 34 RGDPpc y2005 13986 ## 5 Istanbul 34 RGDPpc y2010 14384 ## 6 Istanbul 34 RGDPpc y2015 18602. ## 7 Istanbul 34 GDPpc_USD y2005 12428 ## 8 Istanbul 34 GDPpc_USD y2010 17480 ## 9 Istanbul 34 GDPpc_USD y2015 18343 ## 10 Istanbul 34 population y2005 12000000 ## # ℹ 26 more rows Bu veri setinde satırlarda değişkenler var. Ayrıca yil değişkeninin önünde “y” karakteri var. Bunu aşağıdaki gibi düzeltebiliriz: tr_veri_uzun &lt;- pivot_longer(tr_veri, cols = c(`y2005`, `y2010`, `y2015`), names_to = &quot;yil&quot;, values_to = &quot;olcum&quot;, names_prefix = &quot;y&quot; ) tr_veri_uzun ## # A tibble: 36 × 5 ## il plaka degisken yil olcum ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Istanbul 34 GDPpc 2005 16749 ## 2 Istanbul 34 GDPpc 2010 26253 ## 3 Istanbul 34 GDPpc 2015 49773 ## 4 Istanbul 34 RGDPpc 2005 13986 ## 5 Istanbul 34 RGDPpc 2010 14384 ## 6 Istanbul 34 RGDPpc 2015 18602. ## 7 Istanbul 34 GDPpc_USD 2005 12428 ## 8 Istanbul 34 GDPpc_USD 2010 17480 ## 9 Istanbul 34 GDPpc_USD 2015 18343 ## 10 Istanbul 34 population 2005 12000000 ## # ℹ 26 more rows Şimdi pivot_wider() ile değişkenleri sütunlara alalım: pivot_wider(tr_veri_uzun, names_from = &quot;degisken&quot;, values_from = &quot;olcum&quot;) ## # A tibble: 9 × 7 ## il plaka yil GDPpc RGDPpc GDPpc_USD population ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 34 2005 16749 13986 12428 12000000 ## 2 Istanbul 34 2010 26253 14384 17480 13100000 ## 3 Istanbul 34 2015 49773 18602. 18343 14500000 ## 4 Izmir 35 2005 12011 9922. 8912 3626321 ## 5 Izmir 35 2010 18308 10211. 12190 3908672 ## 6 Izmir 35 2015 34261 12927. 12626 4140726 ## 7 Ankara 6 2005 15392 12910. 11420 4252588 ## 8 Ankara 6 2010 23997 13019. 15978 4711187 ## 9 Ankara 6 2015 40679 15029. 14992 5210297 Birleştirilmiş bu düzenli veri setinde il ve yil çifti bir gözlemi oluşturur. İstanbul ilinde 2005 yılında sadece bir satır bulunabilir. 2.3.1 Kayıp gözlemler drop_na(): kayıp gözlemleri sil df &lt;- tibble(x = c(1, 2, NA), y = c(&quot;a&quot;, NA, &quot;b&quot;)) df ## # A tibble: 3 × 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 2 &lt;NA&gt; ## 3 NA b # tüm NA gözlemleri sil drop_na(df) ## # A tibble: 1 × 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a # x sütunundaki NA gözlemleri sil drop_na(df, x) ## # A tibble: 2 × 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 2 &lt;NA&gt; fill(): kayıp gözlemleri bir önceki ya da bir sonraki doldur. Örnek (help dosyasından): sales &lt;- tibble::tribble( ~quarter, ~year, ~sales, &quot;Q1&quot;, 2000, 66013, &quot;Q2&quot;, NA, 69182, &quot;Q3&quot;, NA, 53175, &quot;Q4&quot;, NA, 21001, &quot;Q1&quot;, 2001, 46036, &quot;Q2&quot;, NA, 58842, &quot;Q3&quot;, NA, 44568, &quot;Q4&quot;, NA, 50197, &quot;Q1&quot;, 2002, 39113, &quot;Q2&quot;, NA, 41668, &quot;Q3&quot;, NA, 30144, &quot;Q4&quot;, NA, 52897, &quot;Q1&quot;, 2004, 32129, &quot;Q2&quot;, NA, 67686, &quot;Q3&quot;, NA, 31768, &quot;Q4&quot;, NA, 49094 ) sales ## # A tibble: 16 × 3 ## quarter year sales ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Q1 2000 66013 ## 2 Q2 NA 69182 ## 3 Q3 NA 53175 ## 4 Q4 NA 21001 ## 5 Q1 2001 46036 ## 6 Q2 NA 58842 ## 7 Q3 NA 44568 ## 8 Q4 NA 50197 ## 9 Q1 2002 39113 ## 10 Q2 NA 41668 ## 11 Q3 NA 30144 ## 12 Q4 NA 52897 ## 13 Q1 2004 32129 ## 14 Q2 NA 67686 ## 15 Q3 NA 31768 ## 16 Q4 NA 49094 sales veri setinde yıl değerleri sadece değiştiğinde açıkça yazılmış. Aslında NA değil Q1 dönemindeki yıl değerine eşit. # year değerlerini yukarıdan aşağıya doğru doldur fill(sales, year) ## # A tibble: 16 × 3 ## quarter year sales ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Q1 2000 66013 ## 2 Q2 2000 69182 ## 3 Q3 2000 53175 ## 4 Q4 2000 21001 ## 5 Q1 2001 46036 ## 6 Q2 2001 58842 ## 7 Q3 2001 44568 ## 8 Q4 2001 50197 ## 9 Q1 2002 39113 ## 10 Q2 2002 41668 ## 11 Q3 2002 30144 ## 12 Q4 2002 52897 ## 13 Q1 2004 32129 ## 14 Q2 2004 67686 ## 15 Q3 2004 31768 ## 16 Q4 2004 49094 replace_na(): NA yerine belirtilmiş (bilinen) değerleri yaz. df &lt;- tibble(x = c(1, 2, NA), y = c(&quot;a&quot;, NA, &quot;b&quot;)) df ## # A tibble: 3 × 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 2 &lt;NA&gt; ## 3 NA b # x değişkeninde NA değerleri yerine 0 # y değişkeninde NA değerleri yerine &quot;bilinmiyor&quot; yaz replace_na(df, list(x = 0, y = &quot;bilinmiyor&quot;)) ## # A tibble: 3 × 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 2 bilinmiyor ## 3 0 b complete(): Gizli kayıp gözlemleri açık hale getir. df &lt;- tibble(il = c(&quot;İstanbul&quot;, &quot;İstanbul&quot;, &quot;Ankara&quot;), yil = c(2019, 2020, 2019), kfe = c(250, 300, 220)) df ## # A tibble: 3 × 3 ## il yil kfe ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 İstanbul 2019 250 ## 2 İstanbul 2020 300 ## 3 Ankara 2019 220 complete(df, il, yil) ## # A tibble: 4 × 3 ## il yil kfe ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ankara 2019 220 ## 2 Ankara 2020 NA ## 3 İstanbul 2019 250 ## 4 İstanbul 2020 300 2.3.2 Hücrelerin ayrılması veya birleştirilmesi table3 veri setinde rate değişkeni oran karakteri ile tanımlanmıştı: table3 ## # A tibble: 6 × 3 ## country year rate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 Bu haliyle analizde kullanılması mümkün değildir. Bir sütunun hücrelerini ayırmak için separate() fonksiyonu kullanılabilir: separate(table3, col = rate, sep = &quot;/&quot;, into = c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Hücreler ayrılıp satır haline de getirilebilir: separate_rows(table3, rate, sep = &quot;/&quot;) ## # A tibble: 12 × 3 ## country year rate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 1999 19987071 ## 3 Afghanistan 2000 2666 ## 4 Afghanistan 2000 20595360 ## 5 Brazil 1999 37737 ## 6 Brazil 1999 172006362 ## 7 Brazil 2000 80488 ## 8 Brazil 2000 174504898 ## 9 China 1999 212258 ## 10 China 1999 1272915272 ## 11 China 2000 213766 ## 12 China 2000 1280428583 Alıştırma: Yukarıdaki veri seti “düzenli” formda mıdır? Değilse nasıl düzenli hale getirilebilir? Cevap: table3_a &lt;- separate_rows(table3, rate, sep = &quot;/&quot;) table3_a &lt;- table3_a |&gt; group_by(country, year) |&gt; mutate(rowno = row_number()) table3_a ## # A tibble: 12 × 4 ## # Groups: country, year [6] ## country year rate rowno ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 1 ## 2 Afghanistan 1999 19987071 2 ## 3 Afghanistan 2000 2666 1 ## 4 Afghanistan 2000 20595360 2 ## 5 Brazil 1999 37737 1 ## 6 Brazil 1999 172006362 2 ## 7 Brazil 2000 80488 1 ## 8 Brazil 2000 174504898 2 ## 9 China 1999 212258 1 ## 10 China 1999 1272915272 2 ## 11 China 2000 213766 1 ## 12 China 2000 1280428583 2 table3_b &lt;- pivot_wider(table3_a, names_from = &quot;rowno&quot;, values_from = &quot;rate&quot;) table3_b ## # A tibble: 6 × 4 ## # Groups: country, year [6] ## country year `1` `2` ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table3_b |&gt; rename(cases = `1`, population = `2`) ## # A tibble: 6 × 4 ## # Groups: country, year [6] ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 # sütun isimlerinin önüne bir kelime eklenebilir: pivot_wider(table3_a, names_from = &quot;rowno&quot;, values_from = &quot;rate&quot;, names_prefix = &quot;variable&quot;) ## # A tibble: 6 × 4 ## # Groups: country, year [6] ## country year variable1 variable2 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Bazı durumlarda hücrelerin birleştirilmesi gerekebilir. Örneğin, # century ve year değişkenlerinin hücrelerini birleştirmek isteyebiliriz table5 ## # A tibble: 6 × 4 ## country century year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 table5a &lt;- unite(table5, century, year, col = &quot;year&quot;, sep = &quot;&quot;) table5a ## # A tibble: 6 × 3 ## country year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 # rate sütununu ayır separate(table5a, col = rate, sep = &quot;/&quot;, into = c(&quot;cases&quot;, &quot;population&quot;), convert = TRUE) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 "],["2.4-dplyr.html", "2.4 {dplyr} Paketi ile Verilerin Manipülasyonu", " 2.4 {dplyr} Paketi ile Verilerin Manipülasyonu Verilerin işlenmesi, özetlenmesi, birleştirilmesi, yeni veriler oluşturulması ve benzeri işlemler için çeşitli fonksiyonlar içerir. Temel {dplyr} fonksiyonları şunlardır: filter(): belirli mantıksal ölçütlere uygun alt kümelerin oluşturulması select(): sütunların (değişkenlerin) seçimi mutate(): yeni değişken oluşturma summarize(): verilerin özetlenmesi arrange(): verilerin sıralanması Tüm işlemler, satır seçimi, sütun seçimi, yeni değişken oluşturma, özetleme, sıralama, veri içindeki grup değişken(ler)ine göre yapılabilir. Bunun için group_by() fonksiyonu kullanılır. 2.4.1 filter(): gözlemlerin filtrelenmesi dplyr::filter() fonksiyonu ile satırlara göre alt kümeler oluşturabiliriz. Belirttiğimiz kriterlere uygun gözlemlerden oluşan yeni veri çerçeveleri veya tablolar oluşturabiliriz. Örnek gapminder ülke veri setinde Türkiye’nin gözlemlerini almak istediğimizi düşünelim. Veri setini incelediğimizde Türkiye’nin 1573 ile 1584 satırları arasında yer aldığını görüyoruz. Bu bilgiden hareketle Türkiye veri setini aşağıdaki gibi oluşturabiliriz: library(tidyverse) library(gapminder) (turkey &lt;- gapminder[1573:1584,]) ## # A tibble: 12 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Turkey Europe 1952 43.6 22235677 1969. ## 2 Turkey Europe 1957 48.1 25670939 2219. ## 3 Turkey Europe 1962 52.1 29788695 2323. ## 4 Turkey Europe 1967 54.3 33411317 2826. ## 5 Turkey Europe 1972 57.0 37492953 3451. ## 6 Turkey Europe 1977 59.5 42404033 4269. ## 7 Turkey Europe 1982 61.0 47328791 4241. ## 8 Turkey Europe 1987 63.1 52881328 5089. ## 9 Turkey Europe 1992 66.1 58179144 5678. ## 10 Turkey Europe 1997 68.8 63047647 6601. ## 11 Turkey Europe 2002 70.8 67308928 6508. ## 12 Turkey Europe 2007 71.8 71158647 8458. Satır numaralarını kullanarak verileri çekmek hata olasılığını arttırdığı için tercih edilmemelidir. Bunun yerine dplyr::filter() fonksiyonunu kullanabiliriz. Bu fonksiyonun girdisi verilerin satırlarına uygulanan mantıksal ifadelerdir. Örneğin: filter(gapminder, country == &quot;Turkey&quot;) ## # A tibble: 12 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Turkey Europe 1952 43.6 22235677 1969. ## 2 Turkey Europe 1957 48.1 25670939 2219. ## 3 Turkey Europe 1962 52.1 29788695 2323. ## 4 Turkey Europe 1967 54.3 33411317 2826. ## 5 Turkey Europe 1972 57.0 37492953 3451. ## 6 Turkey Europe 1977 59.5 42404033 4269. ## 7 Turkey Europe 1982 61.0 47328791 4241. ## 8 Turkey Europe 1987 63.1 52881328 5089. ## 9 Turkey Europe 1992 66.1 58179144 5678. ## 10 Turkey Europe 1997 68.8 63047647 6601. ## 11 Turkey Europe 2002 70.8 67308928 6508. ## 12 Turkey Europe 2007 71.8 71158647 8458. Bu fonksiyonun kullanımı baz R’daki subset() fonksiyonuna benzemektedir. filter() fonksiyonu çoklu ifadelerin kullanılmasına izin verir. Örneğin, Türkiye’nin 2000 sonrası verileri için aşağıdaki komutu kullanabiliriz: filter(gapminder, country == &quot;Turkey&quot;, year&gt;2000) ## # A tibble: 2 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Turkey Europe 2002 70.8 67308928 6508. ## 2 Turkey Europe 2007 71.8 71158647 8458. Örnek: Türkiye ve Brezilya’nın 2000 sonrası gözlemlerini içeren bir tablo oluştur: filter(gapminder, country %in% c(&quot;Turkey&quot;,&quot;Brazil&quot;), year&gt;2000) ## # A tibble: 4 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Brazil Americas 2002 71.0 179914212 8131. ## 2 Brazil Americas 2007 72.4 190010647 9066. ## 3 Turkey Europe 2002 70.8 67308928 6508. ## 4 Turkey Europe 2007 71.8 71158647 8458. 2.4.2 select(): değişkenlerin seçimi select() fonksiyonu Sütunlardan (değişkenlerden) hareketle yeni bir tablo (tibble) oluşturmak istersek dplyr::select() fonksiyonunu kullanabiliriz. *Örnek mtcars veri setinde mpg, cyl, hp değişkenlerinden oluşan bir tablo oluştur mtcars ## # A tibble: 32 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # ℹ 22 more rows # dplyr::select() can clash with MASS::select() library(dplyr) mtcars2 &lt;- dplyr::select(mtcars, mpg, cyl, hp) mtcars2 ## # A tibble: 32 × 3 ## mpg cyl hp ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 21 6 110 ## 2 21 6 110 ## 3 22.8 4 93 ## 4 21.4 6 110 ## 5 18.7 8 175 ## 6 18.1 6 105 ## 7 14.3 8 245 ## 8 24.4 4 62 ## 9 22.8 4 95 ## 10 19.2 6 123 ## # ℹ 22 more rows filter() komutu ile birlikte kullanılabilir. Örnek: gapminder veri setinde Türkiye için sadece yıl, yaşam beklentisi ve kişi başına GDP değişkenlerinden oluşan bir veri çerçevesi oluştur: gapminder |&gt; filter(country == &quot;Turkey&quot;) |&gt; select(year, lifeExp, gdpPercap) ## # A tibble: 12 × 3 ## year lifeExp gdpPercap ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1952 43.6 1969. ## 2 1957 48.1 2219. ## 3 1962 52.1 2323. ## 4 1967 54.3 2826. ## 5 1972 57.0 3451. ## 6 1977 59.5 4269. ## 7 1982 61.0 4241. ## 8 1987 63.1 5089. ## 9 1992 66.1 5678. ## 10 1997 68.8 6601. ## 11 2002 70.8 6508. ## 12 2007 71.8 8458. (pipe) işlemcisi %&gt;% (magrittr paketi) veya |&gt; (R native) : bu işlemciyi kullanarak f(g(x)) gibi bir işlemi x %&gt;% g() %&gt;% f() şeklinde yazabiliriz. Böylece yazdığımız programlar daha basit ve anlaşılır olabilir. Önceki örnekte gapminder veri seti önce filter() fonksiyonuna gönderilerek Türkiye seçildi. Sonraki %&gt;% işlemi ile select() fonksiyonuna gönderildi ve sütunlar seçildi. Aynı kodu şöyle de yazabilirdik: select(filter(gapminder, country == &quot;Turkey&quot;), year, lifeExp, gdpPercap) ## # A tibble: 12 × 3 ## year lifeExp gdpPercap ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1952 43.6 1969. ## 2 1957 48.1 2219. ## 3 1962 52.1 2323. ## 4 1967 54.3 2826. ## 5 1972 57.0 3451. ## 6 1977 59.5 4269. ## 7 1982 61.0 4241. ## 8 1987 63.1 5089. ## 9 1992 66.1 5678. ## 10 1997 68.8 6601. ## 11 2002 70.8 6508. ## 12 2007 71.8 8458. Örnek: Türkiye ve Brezilya için 2000 sonrasında kişi başına GDP değişkenini içeren bir tablo oluştur: gapminder |&gt; filter(country %in% c(&quot;Turkey&quot;,&quot;Brazil&quot;), year&gt;2000) |&gt; select(year, country, gdpPercap) ## # A tibble: 4 × 3 ## year country gdpPercap ## &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 2002 Brazil 8131. ## 2 2007 Brazil 9066. ## 3 2002 Turkey 6508. ## 4 2007 Turkey 8458. Alıştırma: Önceki örnekteki tabloyu sadece baz R fonksiyonlarını kullanarak oluşturunuz. Çözüm: R’da bir görevi yerine getirmenin birden çok yolu olabilir. Bir çözüm: gapminder[gapminder$country %in% c(&quot;Turkey&quot;, &quot;Brazil&quot;) &amp; gapminder$year&gt;2000, c(&quot;year&quot;, &quot;gdpPercap&quot;)] ## # A tibble: 4 × 2 ## year gdpPercap ## &lt;int&gt; &lt;dbl&gt; ## 1 2002 8131. ## 2 2007 9066. ## 3 2002 6508. ## 4 2007 8458. Eğer bir sütunu alıp atomik bir vektör oluşturmak istersek pull() fonksiyonunu kullanabiliriz. Örneğin, gapminder veri setindeki ülkelerin isimlerini içeren bir karakter vektörü uluşturalım: ulkeler &lt;- unique(pull(gapminder, country)) head(ulkeler) ## [1] Afghanistan Albania Algeria Angola Argentina Australia ## 142 Levels: Afghanistan Albania Algeria Angola Argentina Australia Austria ... Zimbabwe Sütun seçimine yardımcı olabilecek fonksiyonlar: contains(): bir ifadeyi içeren sütunları seçer ends_with(): belirli bir ifade ile biten sütunları seçer starts_with(): belirli bir ifadeyle başlayan sütunları seçer matches(): bir ifadeyle eşleşen sütunları seçer 2.4.3 mutate(): yeni değişken oluşturma dplyr::mutate() fonksiyonu ile veri setine yeni değişkenler (sütunlar) ekleyebiliriz. mutate() içinde kullanılan fonksiyonlar vektörleştirilmiş olmalıdır; yani hem girdi hem de çıktı vektör olmalıdır. Örnek: Kişi başına GDP’nin doğal logaritmasının ayrı bir değişen olarak veri setine eklenmesi: mutate(gapminder, lgdppc = log(gdpPercap)) |&gt; head(5) ## # A tibble: 5 × 7 ## country continent year lifeExp pop gdpPercap lgdppc ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. 6.66 ## 2 Afghanistan Asia 1957 30.3 9240934 821. 6.71 ## 3 Afghanistan Asia 1962 32.0 10267083 853. 6.75 ## 4 Afghanistan Asia 1967 34.0 11537966 836. 6.73 ## 5 Afghanistan Asia 1972 36.1 13079460 740. 6.61 Örnek: Veri setinde kişi başına GDP değerleri var ancak toplam GDP yok. Nüfus bilgisini kullanarak toplam ülke GDP değerlerini oluşturunuz. mutate(gapminder, gdp = gdpPercap*pop ) |&gt; select(year, country, gdpPercap, pop, gdp) |&gt; head(5) ## # A tibble: 5 × 5 ## year country gdpPercap pop gdp ## &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1952 Afghanistan 779. 8425333 6567086330. ## 2 1957 Afghanistan 821. 9240934 7585448670. ## 3 1962 Afghanistan 853. 10267083 8758855797. ## 4 1967 Afghanistan 836. 11537966 9648014150. ## 5 1972 Afghanistan 740. 13079460 9678553274. mutate() ile ilişkili diğer fonksiyonlar: transmute(): yeni değişkenler oluşturur ve mevcut değişkenleri siler. mutate_all(): bir fonksiyonu tüm sütunlara uygular mutate_if(): sadece kritere uyan sütunlara bir fonksiyonu uygular mutate_at(): bir fonksiyonu belirtilmiş sütunlara uygular Örnekler df &lt;- tibble(x = 1:5, y = 20:16, z = letters[1:5]) df ## # A tibble: 5 × 3 ## x y z ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 1 20 a ## 2 2 19 b ## 3 3 18 c ## 4 4 17 d ## 5 5 16 e # transmute() drops variables after mutating df |&gt; transmute(w = x*y) ## # A tibble: 5 × 1 ## w ## &lt;int&gt; ## 1 20 ## 2 38 ## 3 54 ## 4 68 ## 5 80 # nümerik sütunların doğal logaritmasını ve 10 tabanına göre # logaritmasını al # çoklu dönüştürmeler list() içinde belirtilmeli df |&gt; mutate_if(is.numeric, list(ln = log, log10 = log10)) ## # A tibble: 5 × 7 ## x y z x_ln y_ln x_log10 y_log10 ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 20 a 0 3.00 0 1.30 ## 2 2 19 b 0.693 2.94 0.301 1.28 ## 3 3 18 c 1.10 2.89 0.477 1.26 ## 4 4 17 d 1.39 2.83 0.602 1.23 ## 5 5 16 e 1.61 2.77 0.699 1.20 # character değişkenin varsa factor değişkenine dönüştür df |&gt; mutate_if(is.character, as.factor) ## # A tibble: 5 × 3 ## x y z ## &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 1 20 a ## 2 2 19 b ## 3 3 18 c ## 4 4 17 d ## 5 5 16 e # sadece x ve y&#39;nin karelerini ayrı sütun olarak ekle df |&gt; mutate_at(c(&quot;x&quot;, &quot;y&quot;), list(sq = function(x) x^2)) ## # A tibble: 5 × 5 ## x y z x_sq y_sq ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 20 a 1 400 ## 2 2 19 b 4 361 ## 3 3 18 c 9 324 ## 4 4 17 d 16 289 ## 5 5 16 e 25 256 mutate() içinde kullanılan fonksiyonları vektörize olması gerekir. Yani bir vektör girdisine karşılık bir vektör çıktısı hesaplanır. Bu fonksiyonlardan bazıları şunlardır: dplyr::lag(): bir vektörün gecikmesini alır. stats::lag() ile karıştırılmamalıdır. dplyr::lead(): bir vektörün öncü değerlerini oluşturur. kümülatif aritmetik işlemler: cumall(), cumany(), cummax(), cummean(), cummin(), cumprod(), cumsum() sıralamalar: min_rank(), percent_rank(), row_number(), cume_dist() matematiksel işlemler: +, -, *, /, ^, %%, log, log10, … mantıksal işlemler: ==, &lt;, &lt;=, &gt;, &gt;=, !=, between(), near() if_else(): koşullu işlemleri eleman bazında uygular case_when(): çoklu if-else na_if(): NA değerleri yerine belirli değerleri yaz 2.4.4 arrange(): verilerin sıralanması Veri setinin satırlarının (gözlemlerin) sıralanmasında dplyr::arrange() fonksiyonu kullanılabilir. Örnek: gapminder veri setini yıla göre sırala. arrange(gapminder, year) ## # A tibble: 1,704 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Albania Europe 1952 55.2 1282697 1601. ## 3 Algeria Africa 1952 43.1 9279525 2449. ## 4 Angola Africa 1952 30.0 4232095 3521. ## 5 Argentina Americas 1952 62.5 17876956 5911. ## 6 Australia Oceania 1952 69.1 8691212 10040. ## 7 Austria Europe 1952 66.8 6927772 6137. ## 8 Bahrain Asia 1952 50.9 120447 9867. ## 9 Bangladesh Asia 1952 37.5 46886859 684. ## 10 Belgium Europe 1952 68 8730405 8343. ## # ℹ 1,694 more rows Default olarak küçükten büyüğe sıraladı. Büyükten küçüğe sıralamak istersek: arrange(gapminder, desc(year)) ## # A tibble: 1,704 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 2007 43.8 31889923 975. ## 2 Albania Europe 2007 76.4 3600523 5937. ## 3 Algeria Africa 2007 72.3 33333216 6223. ## 4 Angola Africa 2007 42.7 12420476 4797. ## 5 Argentina Americas 2007 75.3 40301927 12779. ## 6 Australia Oceania 2007 81.2 20434176 34435. ## 7 Austria Europe 2007 79.8 8199783 36126. ## 8 Bahrain Asia 2007 75.6 708573 29796. ## 9 Bangladesh Asia 2007 64.1 150448339 1391. ## 10 Belgium Europe 2007 79.4 10392226 33693. ## # ℹ 1,694 more rows Örnek: Yılı artan, ülkeleri alfabetik olacak şekilde satırları yeniden düzenle: arrange(gapminder, year, country) ## # A tibble: 1,704 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Albania Europe 1952 55.2 1282697 1601. ## 3 Algeria Africa 1952 43.1 9279525 2449. ## 4 Angola Africa 1952 30.0 4232095 3521. ## 5 Argentina Americas 1952 62.5 17876956 5911. ## 6 Australia Oceania 1952 69.1 8691212 10040. ## 7 Austria Europe 1952 66.8 6927772 6137. ## 8 Bahrain Asia 1952 50.9 120447 9867. ## 9 Bangladesh Asia 1952 37.5 46886859 684. ## 10 Belgium Europe 1952 68 8730405 8343. ## # ℹ 1,694 more rows Örnek: Ülkeler alfabetik, yıl artan: arrange(gapminder, country, year) ## # A tibble: 1,704 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## # ℹ 1,694 more rows filter() ve arrange() birlikte kullanılabilir. Örneğin: gapminder |&gt; filter(year==2007, continent==&quot;Americas&quot;) |&gt; arrange(lifeExp) ## # A tibble: 25 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Haiti Americas 2007 60.9 8502814 1202. ## 2 Bolivia Americas 2007 65.6 9119152 3822. ## 3 Trinidad and Tobago Americas 2007 69.8 1056608 18009. ## 4 Honduras Americas 2007 70.2 7483763 3548. ## 5 Guatemala Americas 2007 70.3 12572928 5186. ## 6 Peru Americas 2007 71.4 28674757 7409. ## 7 Paraguay Americas 2007 71.8 6667147 4173. ## 8 El Salvador Americas 2007 71.9 6939688 5728. ## 9 Dominican Republic Americas 2007 72.2 9319622 6025. ## 10 Brazil Americas 2007 72.4 190010647 9066. ## # ℹ 15 more rows Örnek: 2007 yılında Avrupa kıtasındaki ülkelerde yaşam beklentisini büyükten küçüğe sıralayınız. gapminder |&gt; filter(year==2007, continent==&quot;Europe&quot;) |&gt; arrange(desc(lifeExp)) ## # A tibble: 30 × 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Iceland Europe 2007 81.8 301931 36181. ## 2 Switzerland Europe 2007 81.7 7554661 37506. ## 3 Spain Europe 2007 80.9 40448191 28821. ## 4 Sweden Europe 2007 80.9 9031088 33860. ## 5 France Europe 2007 80.7 61083916 30470. ## 6 Italy Europe 2007 80.5 58147733 28570. ## 7 Norway Europe 2007 80.2 4627926 49357. ## 8 Austria Europe 2007 79.8 8199783 36126. ## 9 Netherlands Europe 2007 79.8 16570613 36798. ## 10 Greece Europe 2007 79.5 10706290 27538. ## # ℹ 20 more rows 2.4.5 group_by(): verilerin gruplanması Verilerin gruplandırılması amacıyla kullanılır. Verilerin görünümünü değiştirmez. summarize() gibi diğer fonksiyonlarla birlikte kullanılabilir. gapminder |&gt; group_by(continent, year) ## # A tibble: 1,704 × 6 ## # Groups: continent, year [60] ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## # ℹ 1,694 more rows gapminder |&gt; group_by(continent, year) |&gt; arrange(year) ## # A tibble: 1,704 × 6 ## # Groups: continent, year [60] ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Albania Europe 1952 55.2 1282697 1601. ## 3 Algeria Africa 1952 43.1 9279525 2449. ## 4 Angola Africa 1952 30.0 4232095 3521. ## 5 Argentina Americas 1952 62.5 17876956 5911. ## 6 Australia Oceania 1952 69.1 8691212 10040. ## 7 Austria Europe 1952 66.8 6927772 6137. ## 8 Bahrain Asia 1952 50.9 120447 9867. ## 9 Bangladesh Asia 1952 37.5 46886859 684. ## 10 Belgium Europe 1952 68 8730405 8343. ## # ℹ 1,694 more rows ungroup() ile gruplar çözülebilir. 2.4.6 summarize(): verilerin özetlenmesi summarize() Verilerin özet istatistiklerinin oluşturulmasında dplyr::summarize() kullanılabilir. Bu komut öncesinde group_by() ile veriler gruplandırılarak grup istatistikleri oluşturulabilir. group_by() Örnek: 2007 yılında her bir kıtada kaç ülke var? gapminder |&gt; filter(year==2007) |&gt; group_by(continent) |&gt; summarize(n = n()) ## # A tibble: 5 × 2 ## continent n ## &lt;fct&gt; &lt;int&gt; ## 1 Africa 52 ## 2 Americas 25 ## 3 Asia 33 ## 4 Europe 30 ## 5 Oceania 2 Örnek: 2007 yılında kıtalara göre ortalama yaşam beklentisini ve ortalama kişi başına GDP değerini bulunuz. gapminder |&gt; filter(year==2007) |&gt; group_by(continent) |&gt; summarize(mean_life_exp = mean(lifeExp), mean_income = mean(gdpPercap)) ## # A tibble: 5 × 3 ## continent mean_life_exp mean_income ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 54.8 3089. ## 2 Americas 73.6 11003. ## 3 Asia 70.7 12473. ## 4 Europe 77.6 25054. ## 5 Oceania 80.7 29810. Kullanışlı diğer fonksiyonlar: summarize_at(): belirli değişkenlerin özet istatistiklerini hesaplar summarize_all(): tüm değişkenlerin özet istatistiklerini hesaplar. summarize_if(): sadece bir tip değişkenlerin değerlerini hesaplar. Örnek: summarize_at() kullanımı: gapminder |&gt; filter(year==2007) |&gt; group_by(continent) |&gt; summarize_at(vars(lifeExp, gdpPercap), mean) ## # A tibble: 5 × 3 ## continent lifeExp gdpPercap ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 54.8 3089. ## 2 Americas 73.6 11003. ## 3 Asia 70.7 12473. ## 4 Europe 77.6 25054. ## 5 Oceania 80.7 29810. Örnek: gapminder |&gt; filter(year==2007) |&gt; group_by(continent) |&gt; summarize_at(vars(lifeExp, gdpPercap), list(min = min, max = max)) ## # A tibble: 5 × 5 ## continent lifeExp_min gdpPercap_min lifeExp_max gdpPercap_max ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 39.6 278. 76.4 13206. ## 2 Americas 60.9 1202. 80.7 42952. ## 3 Asia 43.8 944 82.6 47307. ## 4 Europe 71.8 5937. 81.8 49357. ## 5 Oceania 80.2 25185. 81.2 34435. Örnek: Önceki işlemi 1952 ve 2007 yılları için yapalım ve ortalamaları karşılaştıralım: gapminder |&gt; filter(year %in% c(1952, 2007)) |&gt; group_by(continent, year) |&gt; summarize_at(vars(lifeExp, gdpPercap), mean) ## # A tibble: 10 × 4 ## # Groups: continent [5] ## continent year lifeExp gdpPercap ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 1952 39.1 1253. ## 2 Africa 2007 54.8 3089. ## 3 Americas 1952 53.3 4079. ## 4 Americas 2007 73.6 11003. ## 5 Asia 1952 46.3 5195. ## 6 Asia 2007 70.7 12473. ## 7 Europe 1952 64.4 5661. ## 8 Europe 2007 77.6 25054. ## 9 Oceania 1952 69.3 10298. ## 10 Oceania 2007 80.7 29810. Gruplamanın iki değişken üzerinden group_by(continent, year) yapıldığına dikkat ediniz. summarise() ile kullanılabiliecek fonksiyonlar aşağıda listelenmiştir. Bu fonksiyonların girdiden hareketle sadece bir özet istatistik verdiğine dikkat ediniz: n(): satır (gözlem) sayısı n_distinct(): farklı gözlem sayısı sum(): toplam sum(!is.na()): NA olmayan gözlem sayısı first(): ilk değer last(): son değer nth(): n.nci sıradaki değer mean(): örneklem ortalaması, median(): medyan, var(): örneklem varyansı, sd(): örneklem standart sapması, mad(): medyan mutlak hata (median absolute deviation), IQR(): kartiller aralığı (interquartile range), min(): minimum, max(): maksimum quantile(): n.nci dilim Örnek: Avrupa’da her yıl için minimum ve maksimum yaşam beklentisini bulunuz. gapminder |&gt; filter(continent==&quot;Europe&quot;) |&gt; group_by(year) |&gt; summarize(minlexp = min(lifeExp), maxlexp = max(lifeExp) ) ## # A tibble: 12 × 3 ## year minlexp maxlexp ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1952 43.6 72.7 ## 2 1957 48.1 73.5 ## 3 1962 52.1 73.7 ## 4 1967 54.3 74.2 ## 5 1972 57.0 74.7 ## 6 1977 59.5 76.1 ## 7 1982 61.0 77.0 ## 8 1987 63.1 77.4 ## 9 1992 66.1 78.8 ## 10 1997 68.8 79.4 ## 11 2002 70.8 80.6 ## 12 2007 71.8 81.8 mutate() ve group_by() fonksiyonlarının birlikte kullanılabilir: Örnek: Her ülke için kişi başına GDP değişkeninin başlangıç yılındaki değerine oranını gösteren yeni bir değişken oluşturunuz. Yeni değişken başlangıç yılı olan 1952’de 1 değerini almalı, diğer yıllar için başlangıç yılına göre (1+büyüme oranı) olmalı. gapminder |&gt; group_by(country) |&gt; select(country, year, gdpPercap) |&gt; mutate(gdppc_to_first = gdpPercap/first(gdpPercap)) ## # A tibble: 1,704 × 4 ## # Groups: country [142] ## country year gdpPercap gdppc_to_first ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1952 779. 1 ## 2 Afghanistan 1957 821. 1.05 ## 3 Afghanistan 1962 853. 1.09 ## 4 Afghanistan 1967 836. 1.07 ## 5 Afghanistan 1972 740. 0.949 ## 6 Afghanistan 1977 786. 1.01 ## 7 Afghanistan 1982 978. 1.25 ## 8 Afghanistan 1987 852. 1.09 ## 9 Afghanistan 1992 649. 0.833 ## 10 Afghanistan 1997 635. 0.815 ## # ℹ 1,694 more rows Örnek: Yıldan yıla büyüme oranlarını yüzde olarak gösteren yeni bir değişken oluşturunuz. gapminder |&gt; group_by(country) |&gt; select(country, year, gdpPercap) |&gt; mutate(gdppc_growth = 100*(gdpPercap-lag(gdpPercap))/lag(gdpPercap)) ## # A tibble: 1,704 × 4 ## # Groups: country [142] ## country year gdpPercap gdppc_growth ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1952 779. NA ## 2 Afghanistan 1957 821. 5.31 ## 3 Afghanistan 1962 853. 3.93 ## 4 Afghanistan 1967 836. -1.98 ## 5 Afghanistan 1972 740. -11.5 ## 6 Afghanistan 1977 786. 6.23 ## 7 Afghanistan 1982 978. 24.4 ## 8 Afghanistan 1987 852. -12.8 ## 9 Afghanistan 1992 649. -23.8 ## 10 Afghanistan 1997 635. -2.16 ## # ℹ 1,694 more rows Örnekte kullanılan lag() fonksiyonu bir önceki dönemdeki (yılda) değere eşit olan birinci gecikmedir. Gecikmeyi açıkça veri setine ekleyelim: gapminder |&gt; group_by(country) |&gt; select(country, year, gdpPercap) |&gt; mutate(lag_gdppc = lag(gdpPercap, 1, order_by = year), gdppc_growth = 100*(gdpPercap-lag_gdppc)/lag_gdppc) ## # A tibble: 1,704 × 5 ## # Groups: country [142] ## country year gdpPercap lag_gdppc gdppc_growth ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1952 779. NA NA ## 2 Afghanistan 1957 821. 779. 5.31 ## 3 Afghanistan 1962 853. 821. 3.93 ## 4 Afghanistan 1967 836. 853. -1.98 ## 5 Afghanistan 1972 740. 836. -11.5 ## 6 Afghanistan 1977 786. 740. 6.23 ## 7 Afghanistan 1982 978. 786. 24.4 ## 8 Afghanistan 1987 852. 978. -12.8 ## 9 Afghanistan 1992 649. 852. -23.8 ## 10 Afghanistan 1997 635. 649. -2.16 ## # ℹ 1,694 more rows Yukarıda pipe operatörünü kullandık. Bunu kullanmadan aynı kodu çalıştırmak istersek: mutate(select(group_by(gapminder,country), country, year, gdpPercap), gdppc_growth = 100*(gdpPercap-lag(gdpPercap))/lag(gdpPercap)) ## # A tibble: 1,704 × 4 ## # Groups: country [142] ## country year gdpPercap gdppc_growth ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1952 779. NA ## 2 Afghanistan 1957 821. 5.31 ## 3 Afghanistan 1962 853. 3.93 ## 4 Afghanistan 1967 836. -1.98 ## 5 Afghanistan 1972 740. -11.5 ## 6 Afghanistan 1977 786. 6.23 ## 7 Afghanistan 1982 978. 24.4 ## 8 Afghanistan 1987 852. -12.8 ## 9 Afghanistan 1992 649. -23.8 ## 10 Afghanistan 1997 635. -2.16 ## # ℹ 1,694 more rows Bunu okumanın daha zor olduğu açıktır. Örnek: Avrupa’da en düşük ve en yüksek yaşam beklentisini ülke bilgisiyle birlikte oluşturunuz. Önce, europe isimli yeni bir tibble yaratalım: europe &lt;- gapminder |&gt; filter(continent==&quot;Europe&quot;) |&gt; select(year, country, lifeExp) europe |&gt; head(10) ## # A tibble: 10 × 3 ## year country lifeExp ## &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 1952 Albania 55.2 ## 2 1957 Albania 59.3 ## 3 1962 Albania 64.8 ## 4 1967 Albania 66.2 ## 5 1972 Albania 67.7 ## 6 1977 Albania 68.9 ## 7 1982 Albania 70.4 ## 8 1987 Albania 72 ## 9 1992 Albania 71.6 ## 10 1997 Albania 73.0 Daha sonra min_rank() ile yaşam beklentisini küçükten büyüğe doğru sıralayalım ve yeni bir değişken yaratarak sıralamaları kaydedelim. En düşük yaşam beklentisine sahip ilk iki ülkeyi listeleyelim: europe |&gt; group_by(year) |&gt; mutate(le_rank = min_rank(lifeExp)) |&gt; filter(le_rank &lt; 3) |&gt; arrange(year) ## # A tibble: 24 × 4 ## # Groups: year [12] ## year country lifeExp le_rank ## &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1952 Bosnia and Herzegovina 53.8 2 ## 2 1952 Turkey 43.6 1 ## 3 1957 Bosnia and Herzegovina 58.4 2 ## 4 1957 Turkey 48.1 1 ## 5 1962 Bosnia and Herzegovina 61.9 2 ## 6 1962 Turkey 52.1 1 ## 7 1967 Bosnia and Herzegovina 64.8 2 ## 8 1967 Turkey 54.3 1 ## 9 1972 Bosnia and Herzegovina 67.4 2 ## 10 1972 Turkey 57.0 1 ## # ℹ 14 more rows Aynısını en yüksek yaşam beklentisi için yapalım: europe |&gt; group_by(year) |&gt; mutate(le_desc_rank = min_rank(desc(lifeExp))) |&gt; filter(le_desc_rank &lt; 3) |&gt; arrange(year) ## # A tibble: 24 × 4 ## # Groups: year [12] ## year country lifeExp le_desc_rank ## &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1952 Iceland 72.5 2 ## 2 1952 Norway 72.7 1 ## 3 1957 Iceland 73.5 1 ## 4 1957 Norway 73.4 2 ## 5 1962 Iceland 73.7 1 ## 6 1962 Norway 73.5 2 ## 7 1967 Norway 74.1 2 ## 8 1967 Sweden 74.2 1 ## 9 1972 Iceland 74.5 2 ## 10 1972 Sweden 74.7 1 ## # ℹ 14 more rows Alıştırma: Minimum ve maksimum yaşam beklentisini birlikte gösteren bir tablo oluşturunuz. 2.4.7 Veri setlerinin birleştirilmesi table4a ve table4b verilerini daha önce nasıl düzenli hale getireceğimizi görmmüştük. Şimdi bu iki veri setini birleştirelim. table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4a_tidy &lt;- pivot_longer(table4a, cols = 2:3, names_to = &quot;year&quot;, values_to = &quot;cases&quot;) table4a_tidy ## # A tibble: 6 × 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 table4b_tidy &lt;- pivot_longer(table4b, cols = 2:3, names_to = &quot;year&quot;, values_to = &quot;population&quot;) table4b_tidy ## # A tibble: 6 × 3 ## country year population ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 19987071 ## 2 Afghanistan 2000 20595360 ## 3 Brazil 1999 172006362 ## 4 Brazil 2000 174504898 ## 5 China 1999 1272915272 ## 6 China 2000 1280428583 Birleştirme için dplyr::left_join() fonksiyonu kullanılabilir: # country, year anahtarları ile birleştir left_join(table4a_tidy, table4b_tidy, by = c(&quot;country&quot;, &quot;year&quot;)) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Aşağıda listelenen birleştirme fonksiyonları (mutating joins) veri2’nin sütunlarını veri1’in sütunları ile belirli anahtar değerler yardımıyla eşleştirerek yeni sütunlar yaratır: left_join(veri1, veri2): veri1’in tüm satırlarını eşleştirir right_join(veri1, veri2): veri2’nin tüm satırlarını eşleştirir inner_join(veri1, veri2): her iki veri setinin eşleşen satırlarını muhafaza eder full_join(veri1, veri2): veri1 ve veri2’nin tüm satırlarını muhafaza eder. veri1 &lt;- tibble(id = c(&quot;Istanbul&quot;, &quot;Istanbul&quot;, &quot;Ankara&quot;, &quot;Ankara&quot;, &quot;Izmir&quot;, &quot;Izmir&quot;), year = c(2019, 2020, 2019, 2020,2019, 2020), x = c(50, 60, 30, 20, 40, NA)) veri1 ## # A tibble: 6 × 3 ## id year x ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 2019 50 ## 2 Istanbul 2020 60 ## 3 Ankara 2019 30 ## 4 Ankara 2020 20 ## 5 Izmir 2019 40 ## 6 Izmir 2020 NA veri2 &lt;- tibble(id = c(&quot;Istanbul&quot;, &quot;Istanbul&quot;, &quot;Ankara&quot;, &quot;Izmir&quot;, &quot;Izmir&quot;, &quot;Antalya&quot;), year = c(2019, 2020, 2019, 2019, 2020, 2019), y = c(1000, 1200, 800, 600, 650, 500)) veri2 ## # A tibble: 6 × 3 ## id year y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 2019 1000 ## 2 Istanbul 2020 1200 ## 3 Ankara 2019 800 ## 4 Izmir 2019 600 ## 5 Izmir 2020 650 ## 6 Antalya 2019 500 # left_join() veri1&#39;in satırlarını muhafaza eder, veri2&#39;nin eşleşmeyen # satırları alınmaz left_join(veri1, veri2, by = c(&quot;id&quot;, &quot;year&quot;)) ## # A tibble: 6 × 4 ## id year x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 2019 50 1000 ## 2 Istanbul 2020 60 1200 ## 3 Ankara 2019 30 800 ## 4 Ankara 2020 20 NA ## 5 Izmir 2019 40 600 ## 6 Izmir 2020 NA 650 # right_join() veri2&#39;nin satırlarını muhafaza eder # eşleşmeyen satırlar = NA right_join(veri1, veri2, by = c(&quot;id&quot;, &quot;year&quot;)) ## # A tibble: 6 × 4 ## id year x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 2019 50 1000 ## 2 Istanbul 2020 60 1200 ## 3 Ankara 2019 30 800 ## 4 Izmir 2019 40 600 ## 5 Izmir 2020 NA 650 ## 6 Antalya 2019 NA 500 inner_join(veri1, veri2, by = c(&quot;id&quot;, &quot;year&quot;)) ## # A tibble: 5 × 4 ## id year x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 2019 50 1000 ## 2 Istanbul 2020 60 1200 ## 3 Ankara 2019 30 800 ## 4 Izmir 2019 40 600 ## 5 Izmir 2020 NA 650 full_join(veri1, veri2, by = c(&quot;id&quot;, &quot;year&quot;)) ## # A tibble: 7 × 4 ## id year x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 2019 50 1000 ## 2 Istanbul 2020 60 1200 ## 3 Ankara 2019 30 800 ## 4 Ankara 2020 20 NA ## 5 Izmir 2019 40 600 ## 6 Izmir 2020 NA 650 ## 7 Antalya 2019 NA 500 bind_cols(): veri setlerinin sütunlarını oldukları gibi yan yana yapıştırır. Gözlemlerin (satırların) hizalanmış olması gerekir. bind_rows(): veri setlerinin satırlarını (gözlemleri) alt alta yapıştırır. Sütunların hizalanmış olması gerekir. Yeni gözlemlerin eklenmesi için kullanılabilir. Alıştırma: Aşağıdaki tabloyu veri1 ve veri2 tablolarıyla nasıl birleştirirsiniz? veri3’ün yeni satırlar içerdiğine dikkat ediniz. veri3 &lt;- tibble(id = c(&quot;Bursa&quot;, &quot;Bursa&quot;, &quot;Adana&quot;, &quot;Adana&quot;), year = c(2019, 2020, 2019, 2020), x = c(110, 115, 160, 140), y = c(350, 380, 440, 430)) veri3 ## # A tibble: 4 × 4 ## id year x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Bursa 2019 110 350 ## 2 Bursa 2020 115 380 ## 3 Adana 2019 160 440 ## 4 Adana 2020 140 430 Çözüm veri1 |&gt; full_join(veri2) |&gt; bind_rows(veri3) ## Joining with `by = join_by(id, year)` ## # A tibble: 11 × 4 ## id year x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Istanbul 2019 50 1000 ## 2 Istanbul 2020 60 1200 ## 3 Ankara 2019 30 800 ## 4 Ankara 2020 20 NA ## 5 Izmir 2019 40 600 ## 6 Izmir 2020 NA 650 ## 7 Antalya 2019 NA 500 ## 8 Bursa 2019 110 350 ## 9 Bursa 2020 115 380 ## 10 Adana 2019 160 440 ## 11 Adana 2020 140 430 2.4.8 Diğer fonksiyonlar 2.4.8.1 rename() Mevcut değişkenleri yeniden isimlendirir. gapminder |&gt; filter(country == &quot;Turkey&quot;) |&gt; rename(life_exp = lifeExp, gdp_pc = gdpPercap ) ## # A tibble: 12 × 6 ## country continent year life_exp pop gdp_pc ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Turkey Europe 1952 43.6 22235677 1969. ## 2 Turkey Europe 1957 48.1 25670939 2219. ## 3 Turkey Europe 1962 52.1 29788695 2323. ## 4 Turkey Europe 1967 54.3 33411317 2826. ## 5 Turkey Europe 1972 57.0 37492953 3451. ## 6 Turkey Europe 1977 59.5 42404033 4269. ## 7 Turkey Europe 1982 61.0 47328791 4241. ## 8 Turkey Europe 1987 63.1 52881328 5089. ## 9 Turkey Europe 1992 66.1 58179144 5678. ## 10 Turkey Europe 1997 68.8 63047647 6601. ## 11 Turkey Europe 2002 70.8 67308928 6508. ## 12 Turkey Europe 2007 71.8 71158647 8458. 2.4.8.2 relocate() Sütunların konumunu değiştirir, satırları etkilemez ve grupları değiştirmez. gapminder |&gt; filter(country == &quot;Turkey&quot;) |&gt; rename(life_exp = lifeExp, gdp_pc = gdpPercap ) |&gt; relocate(gdp_pc, .after = year) ## # A tibble: 12 × 6 ## country continent year gdp_pc life_exp pop ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Turkey Europe 1952 1969. 43.6 22235677 ## 2 Turkey Europe 1957 2219. 48.1 25670939 ## 3 Turkey Europe 1962 2323. 52.1 29788695 ## 4 Turkey Europe 1967 2826. 54.3 33411317 ## 5 Turkey Europe 1972 3451. 57.0 37492953 ## 6 Turkey Europe 1977 4269. 59.5 42404033 ## 7 Turkey Europe 1982 4241. 61.0 47328791 ## 8 Turkey Europe 1987 5089. 63.1 52881328 ## 9 Turkey Europe 1992 5678. 66.1 58179144 ## 10 Turkey Europe 1997 6601. 68.8 63047647 ## 11 Turkey Europe 2002 6508. 70.8 67308928 ## 12 Turkey Europe 2007 8458. 71.8 71158647 gapminder |&gt; filter(country == &quot;Turkey&quot;) |&gt; rename(life_exp = lifeExp, gdp_pc = gdpPercap ) |&gt; relocate(gdp_pc, .before = life_exp) ## # A tibble: 12 × 6 ## country continent year gdp_pc life_exp pop ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Turkey Europe 1952 1969. 43.6 22235677 ## 2 Turkey Europe 1957 2219. 48.1 25670939 ## 3 Turkey Europe 1962 2323. 52.1 29788695 ## 4 Turkey Europe 1967 2826. 54.3 33411317 ## 5 Turkey Europe 1972 3451. 57.0 37492953 ## 6 Turkey Europe 1977 4269. 59.5 42404033 ## 7 Turkey Europe 1982 4241. 61.0 47328791 ## 8 Turkey Europe 1987 5089. 63.1 52881328 ## 9 Turkey Europe 1992 5678. 66.1 58179144 ## 10 Turkey Europe 1997 6601. 68.8 63047647 ## 11 Turkey Europe 2002 6508. 70.8 67308928 ## 12 Turkey Europe 2007 8458. 71.8 71158647 2.4.8.3 distinct() Tekrar eden satırları siler. df &lt;- tibble(x = c(1:5, 5), y = c(11:15, 15), z = c(letters[1:5], &quot;e&quot;)) df ## # A tibble: 6 × 3 ## x y z ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 11 a ## 2 2 12 b ## 3 3 13 c ## 4 4 14 d ## 5 5 15 e ## 6 5 15 e # distinct gözlem sayısı nrow(distinct(df)) ## [1] 5 # distinct gözlemler df |&gt; distinct() ## # A tibble: 5 × 3 ## x y z ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 11 a ## 2 2 12 b ## 3 3 13 c ## 4 4 14 d ## 5 5 15 e "],["2.5-ggplot.html", "2.5 {ggplot2} Paketi ile Görselleştirme", " 2.5 {ggplot2} Paketi ile Görselleştirme {ggplot2} verilerin görselleştirilmesinde grafiklerin grameri (grammar of graphics) yaklaşımını benimser. Hadley Wickham tarafından geliştirilmiş bir R kütüphanesi olan {ggplot2} Tidyverse meta-paketinin bir parçasıdır. Dolayısıyla library(tidyverse) komutuyla otomatik olarak aktif hale gelir. Eğer diğer bileşenlerini istemiyorsak {ggplot2} paketini bağımsız olarak da çağırabiliriz: library(ggplot2) {ggplot2} bir grafiği, veri, geometrik şekiller, renkler, haritalama, istatistik, konum, koordinat sistemi ve fasetlerin katmanlar halinde kullanılmasıyla oluşturur. Tipik bir grafik için şablon aşağıdaki gibi yazılabilir: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; ggplot2 ile ilgili temel kaynaklar: Hadley Wickham ve Garret Grolemund, R for Data Science, Data Visualization with ggplot2 Hadley Wickham, ggplot2: Elegant Graphics for Data Analysis Winston Chang, R Graphics Cookbook: Practical Recipes for Visualizing Data 2.5.1 Bir grafiğin katmanları {ggplot2} bir istatistiksel grafiği katmanlar halinde oluşturur. Paketteki temel fonksiyonu, ggplot(), boş olarak çalıştırdığımızda geometrik nesneler ve renk, şekil ve büyüklük gibi estetik bileşenlerle dolduracağımız bir kanvas elde ederiz: ggplot() Grafiği oluşturmak için veri setimizi, ne tür grafik istediğimizi ve diğer tüm detayları bildirmemiz gerekir. Örnek olarak gapminder veri setinde yaşam beklentisi ile kişi başına gelir arasındaki ilişkiyi görselleştirelim: library(gapminder) ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) Grafiğin eksenleri belirlendi. Ancak grafiğin türünün ne olduğu belirtilmediği için ggplot() boş bir grafik çizdi. {ggplot2} jargonunda geom ismi verilen grafik türlerinin (ya da geometrik şekillerin) eklenmesiyle grafik en yalın haliyle tamamlanır: ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) + geom_point() Grafiği aşağıdaki komut dizisiyle de çizebilirdik: ggplot(data = gapminder) + geom_point(mapping = aes(x = gdpPercap, y = lifeExp)) Grafiği bir nesne ismi tanımlayarak daha sonra tekrar kullanabiliriz. Örneğin grafik1 &lt;- ggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) + geom_point() Grafik çıktı olarak üretilmedi. Bunun için grafik1 Sadece veri ve estetik kısmını tanımlayıp geometrik nesne bilgisi daha sonra da ekleyebiliriz: grafik2 &lt;- ggplot(gapminder, aes(x = log(gdpPercap), y = lifeExp)) grafik2 + geom_point() 2.5.2 Renk, şekil, ve büyüklük Grafiğimize renkleri, şekilleri, ve büyüklükleri kullanarak başka bir değişkenin bilgisini ekleyebiliriz. Renk ve şekiller kategorik değişkenler (örneğin bir ülkenin bulunduğu kıta), büyüklük ise sürekli değişkenler için daha uygundur (örneğin bir ülkenin nüfusu). gapminder veri setinde kişi başına GDP ve yaşam beklentisi arasındaki serpilme çiziminde ülkenin bulunduğu kıta bilgisini renklerle görselleştirelim: library(gapminder) ggplot(gapminder, aes(x = log(gdpPercap), y = lifeExp, color = continent)) + geom_point() Renk estetiği geom_point() içinde de tanımlanabilir: ggplot(gapminder, aes(x = log(gdpPercap), y = lifeExp)) + geom_point(aes(color=continent)) Kategorik bir değişkene ilişkin bilgi renkler yerine şekiller aracılığı ile de gösterilebilir. Bunun için aes() içinde shape = değişkeninin tanımlanması yeterli olur: ggplot(gapminder, aes(x = log(gdpPercap), y = lifeExp, shape = continent)) + geom_point() Benzer şekilde ülkelerin nüfus bilgisini size estetik bileşenini kullanarak tanımlayabiliriz: # sadece 2007 yılı gapminder |&gt; filter(year==2007) |&gt; ggplot(aes(gdpPercap, lifeExp, size = pop)) + geom_point(alpha = 0.5) Burada geom_point() içinde yer alan alpha opsiyonu ile estetik bileşenlerin şeffaflığını kontrol edebiliriz. alpha parametresi 0 ile 1 arasında değerler alır, 1 durumunda mat, 0 durumunda ise şekiller görünmez olur (deneyin). # Örnek: `diamonds` data, karat ve fiyat serpilme çizimi: ggplot(diamonds, aes(carat, price)) + geom_point(alpha = 0.3) color ve size birlikte kullanılabilir: # tüm yıllar ggplot(gapminder, aes(x = log(gdpPercap), y = lifeExp, color = continent, size=pop/1000)) + geom_point(alpha = 0.5) 2.5.3 Fasetler Veri setimizde kategorik değişkenler için ayrı ayrı grafikler (facet) oluşturabiliriz. Örneğin gapminder veri setinde her kıta için ayrı ayrı serpilme çizimlerini oluşturalım. ggplot(gapminder, aes(x = log(gdpPercap), y = lifeExp, size=pop/1000)) + geom_point(alpha = 0.5) + facet_grid(continent ~. ) ggplot(gapminder, aes(x = log(gdpPercap), y = lifeExp, size=pop/1000)) + geom_point(alpha = 0.5) + facet_grid(. ~ continent) gapminder |&gt; filter(year %in% c(1952, 2007)) |&gt; ggplot(aes(x = log(gdpPercap), y = lifeExp)) + geom_point(alpha = 0.5) + facet_grid(year ~ continent) Alternatif olarak facet_wrap() fonksiyonunu kullanabiliriz: ggplot(gapminder, aes(x = log(gdpPercap), y = lifeExp)) + geom_point(alpha = 0.5) + facet_wrap(. ~ continent, ncol = 2) 2.5.4 Eksenler, başlık, ve etiketlerin kontrolü Önce grafiğimizi oluşturalım: # sadece 2007 yılı g2007 &lt;- gapminder |&gt; filter(year==2007) |&gt; ggplot(aes(gdpPercap, lifeExp, size = pop, color = continent)) + geom_point() g2007 Eksen başlıklarını değiştirelim: g2007 + xlab(&quot;Kişi başına Gayri Safi Yurtiçi Hasıla (ABD Doları)&quot;) + ylab(&quot;Yaşam Beklentisi&quot;) Aynı işlem labs() fonksiyonu ile de yapılabilir. Başlık, alt başlık, ve dipnot ekleyelim: g2007 + labs(x = &quot;Kişi başına Gayri Safi Yurtiçi Hasıla (ABD Doları)&quot;, y = &quot;Yaşam Beklentisi&quot;, title = &quot;2007&quot;, subtitle = &quot;Tüm ülkeler&quot;, caption = &quot;Kaynak: Gapminder project, https://www.gapminder.org/&quot; ) scale_x_* veya scale_y_* fonksiyonlarını kullanarak eksenlerin ölçü birimlerini değiştirmek mümkündür. Örneğin yukarıdaki grafikte kişi başına GDP’yi logaritmik skala ile göstermek istersek scale_x_log10() fonksiyonunu kullanabiliriz: g2007 + scale_x_log10() + labs(x = &quot;Kişi başına Gayri Safi Yurtiçi Hasıla (logaritmik skala)&quot;, y = &quot;Yaşam Beklentisi&quot;, title = &quot;2007&quot;, subtitle = &quot;Tüm ülkeler&quot;, caption = &quot;Kaynak: Gapminder project, https://www.gapminder.org/&quot; ) Etiket başlıklarını değiştirelim: g2007 + scale_x_log10() + labs(x = &quot;Kişi başına Gayri Safi Yurtiçi Hasıla (logaritmik skala)&quot;, y = &quot;Yaşam Beklentisi&quot;, color = &quot;Kıta&quot;, size = &quot;Nüfus&quot;, title = &quot;2007&quot;, subtitle = &quot;Tüm ülkeler&quot;, caption = &quot;Kaynak: Gapminder project, https://www.gapminder.org/&quot; ) Grafiği pdf ya da png formatında saklamak için manuel olarak RStudio Plots penceresinden Export seçilebilir. Alternatif olarak ggsave() fonksiyonu kullanılabilir. # en son grafiği gapplot1 ismiyle sakla ggsave(&quot;img/gapplot1.pdf&quot;) ## Saving 7 x 5 in image ggsave(&quot;img/gapplot1.png&quot;) ## Saving 7 x 5 in image 2.5.5 Dağılım Grafikleri Sürekli bir değişkenin dağılımı betimsel istatistiğin önemli bir parçasıdır. Verilerin daha iyi anlaşılmasında histogram, kutu çizimi, birikimli dağılım fonksiyonu gibi görsel araçlar çok faydalı olabilir. 2.5.6 Histogram: geom_histogram() Örnek: Önce yapay bir veri seti oluşturalım. Veriler 3 derse ilişkin notları göstersin. set.seed(1) n &lt;- 200 notlar1 &lt;- round(rnorm(n, mean = 50, sd = 10)) notlar2 &lt;- round(rnorm(n, mean = 60, sd = 15)) notlar3 &lt;- round(rnorm(n, mean = 70, sd = 12)) ders &lt;- factor( rep(c(&quot;Ekonometri-1&quot;,&quot;Ekonometri-2&quot;,&quot;Makine Öğrenmesi&quot;), each=n) ) not_verileri &lt;- tibble(ders, not = c(notlar1, notlar2, notlar3), cinsiyet = sample(c(&quot;Kadın&quot;, &quot;Erkek&quot;), 3*n, replace = TRUE)) not_verileri &lt;- filter(not_verileri, not&lt;=100 &amp; not&gt;=0) head(not_verileri) ## # A tibble: 6 × 3 ## ders not cinsiyet ## &lt;fct&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Ekonometri-1 44 Kadın ## 2 Ekonometri-1 52 Erkek ## 3 Ekonometri-1 42 Kadın ## 4 Ekonometri-1 66 Erkek ## 5 Ekonometri-1 53 Kadın ## 6 Ekonometri-1 42 Erkek not_verileri |&gt; filter(ders == &quot;Ekonometri-1&quot;) |&gt; ggplot() + geom_histogram(mapping = aes(x = not)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Histogramın default değerleri pek göze hitap etmiyor, sınıflar birbiriyle kaynaşmış ve sınıf sayısı da optimal değil. Yeniden çizelim: not_verileri |&gt; filter(ders == &quot;Ekonometri-1&quot;) |&gt; ggplot(mapping = aes(x = not)) + geom_histogram(binwidth = 5, # sütun genişliği color = &quot;darkblue&quot;, # sütun sınırlarının rengi fill = &quot;lightblue&quot; # sütun içinin rengi ) Diğer dersler için de histogramları çizelim ve yan yana paneller oluşturalım: ggplot(data = not_verileri) + geom_histogram(mapping = aes(x = not), binwidth = 10, color = &quot;darkblue&quot;, fill = &quot;lightblue&quot; ) + facet_wrap(~ ders) - Grupların histogramlarını aynı grafikte göster: not_verileri |&gt; ggplot(aes(x = not, fill = ders)) + geom_histogram(binwidth=5, alpha=.5, position=&quot;identity&quot;) Histogram üzerinde ortalama veya medyan notu bir çizgi ya da nokta ile gösterebiliriz. not_ort &lt;- not_verileri |&gt; group_by(ders) |&gt; summarize(n = n(), ortalama = mean(not), medyan = median(not), sd = sd(not), se_ort = ortalama/sqrt(n), p25 = quantile(not, 0.25), p75 = quantile(not, 0.75) ) not_ort ## # A tibble: 3 × 8 ## ders n ortalama medyan sd se_ort p25 p75 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ekonometri-1 200 50.4 49.5 9.30 3.56 44 56 ## 2 Ekonometri-2 200 60.6 60 15.2 4.28 52.8 71 ## 3 Makine Öğrenmesi 199 69.3 69 12.4 4.91 61 77.5 not_verileri |&gt; filter(ders == &quot;Ekonometri-1&quot;) |&gt; ggplot(mapping = aes(x = not)) + geom_histogram(binwidth = 5, # sütun genişliği color = &quot;darkblue&quot;, # sütun sınırlarının rengi fill = &quot;lightblue&quot; # sütun içinin rengi ) + geom_vline(aes(xintercept = mean(not)), # dikey çizginin yeri=ortalama linetype = &quot;dashed&quot;, # çizgi tipi color = &quot;red&quot;, # çizgi rengi size = 1 # çizgi büyüklüğü ) + annotate(geom = &quot;text&quot;, # geom türü label = &quot;Ortalama&quot;, # yazmak istediğimiz etiket/bilgi/yazı x = 53.5, # x koordinatı y = 43) # y koordinatı ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. 2.5.7 Yoğunluk: geom_density() Yoğunluk fonksiyonu düzleştirilmiş histogram gibi düşünülebilir. Örneğin, not_verileri |&gt; filter(ders == &quot;Ekonometri-1&quot;) |&gt; ggplot(aes(x = not)) + geom_histogram(aes(y=..density..), # histogramda y ekseninde yoğunluğu göster bins = 12, color = &quot;black&quot;, fill = &quot;white&quot;) + geom_density(aes(x = not)) ## Warning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0. ## ℹ Please use `after_stat(density)` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. Gruplar için yoğunluk fonksiyonunu aynı grafik üzerinde göster: not_verileri |&gt; ggplot(aes(x = not, fill = ders)) + geom_density(alpha = 0.3) Yukarıdaki grafiğe örneklem ortalamalarını her grup için ekleyelim. Bunun için yukarıda oluşturduğumuz not_ort tablosunu geom_vline() içinde kullanabiliriz. not_verileri |&gt; ggplot(aes(x = not, fill = ders)) + geom_density(alpha = 0.3) + geom_vline(data = not_ort, # özet istatistik tablosu aes(xintercept = ortalama, colour = ders ), linetype=&quot;dashed&quot;, size=1) 2.5.8 Kutu Çizimi: geom_boxplot() not_verileri |&gt; filter(ders == &quot;Ekonometri-2&quot;) |&gt; ggplot(mapping = aes(x = not)) + geom_boxplot() not_verileri |&gt; filter(ders == &quot;Ekonometri-2&quot;) |&gt; ggplot(mapping = aes(y = not)) + geom_boxplot() not_verileri |&gt; ggplot(mapping = aes(x = ders, y = not)) + geom_boxplot() gapminder |&gt; ggplot(mapping = aes(x = factor(year), y = lifeExp)) + geom_boxplot() 2.5.9 Keman grafiği: geom_violin() not_verileri |&gt; ggplot(mapping = aes(x = ders, y = not)) + geom_violin() # kartilleri göster not_verileri |&gt; ggplot(mapping = aes(x = ders, y = not)) + geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) gapminder |&gt; ggplot(mapping = aes(x = factor(year), y = lifeExp)) + geom_violin(draw_quantiles = c(0.5)) 2.5.10 QQ Grafiği Birikimli dağılım fonksiyonunu çizerek normal dağılımla karşılaştırmak isteyebiliriz. Bunun için geom_qq() veya stat_qq() fonksiyonlarını kullanabiliriz. Örnek olarak 5 serbestlik dereceli bir t dağılımından rastgele örneklem çekelim ve grafiğini çizelim. set.seed(54321) data &lt;- tibble(x = rt(400, df = 5)) data |&gt; ggplot(aes(sample = x)) + geom_qq() + geom_qq_line() 2.5.11 Bar plot Sütun grafiği (bar plot): örnek olarak notları derslere ve cinsiyete göre gruplayıp özet istatistiklerini hesaplayalım. Daha sonra grup ortalamalarını bar plot haline getirelim: not_ort2 &lt;- not_verileri |&gt; group_by(ders, cinsiyet) |&gt; summarize(ortalama = mean(not), medyan = median(not), p25 = quantile(not, 0.25), p75 = quantile(not, 0.75) ) not_ort2 ## # A tibble: 6 × 6 ## # Groups: ders [3] ## ders cinsiyet ortalama medyan p25 p75 ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ekonometri-1 Erkek 51.1 50 44 58 ## 2 Ekonometri-1 Kadın 49.6 48 44 55 ## 3 Ekonometri-2 Erkek 61.1 62 50 71 ## 4 Ekonometri-2 Kadın 60.2 59 54 71 ## 5 Makine Öğrenmesi Erkek 69.9 71 62 78 ## 6 Makine Öğrenmesi Kadın 68.7 68 61 76.2 not_ort2 |&gt; ggplot(aes(x = ders, y = ortalama, fill = cinsiyet)) + geom_bar(stat = &quot;identity&quot;, # istatistik hesaplama position = position_dodge() # sütunları yan yana göster ) Örnek: gapminder veri setinde her kıtadaki ülke sayısını bar plot olarak göster: gapminder |&gt; group_by(continent) |&gt; summarize(n = n()) |&gt; ggplot(aes(x = continent, y = n)) + geom_bar(stat = &quot;identity&quot;, position = position_dodge()) Her grup için ortalama çevresinde %95 güven aralığını çizmek istersek geom_pointrange() ya da geom_errorbar() fonksiyonlarını kullanabiliriz: not_ort |&gt; ggplot(aes(ders, # grup ortalama, # istatistik ymin = ortalama-1.96*se_ort, # alt sınır ymax = ortalama+1.96*se_ort # üst sınır ) ) + geom_pointrange() stat_summary() fonksiyonu ile medyan, minimum ve maksimum değerlerin gösterilmesi: ggplot(data = not_verileri) + stat_summary( mapping = aes(x = ders, y = not), fun.min = min, fun.max = max, fun = median ) 2.5.12 Çizgi ve Nokta grafiği Örnek: Türkiye’nin kişi başına GDP değerlerinin zaman serisi grafiğini çiz. library(gapminder) turkey &lt;- gapminder |&gt; filter(country==&quot;Turkey&quot;) ggplot(turkey, aes(x = year, y = gdpPercap)) + geom_line() + geom_point() + xlab(&quot;&quot;) + ylab(&quot;GDP per capita&quot;) + ggtitle(&quot;Turkey&quot;) Örnek: Düşük gelirli Avrupa ülkelerinde yaşam beklentisinin zaman serisi grafiğini çiz. Düşük gelir durumu: 2007 yılında gdpPercap&lt;10000 ise düşük gelirli ülke; değilse yüksek gelirli ülke. # verileri oluştur europe &lt;- gapminder |&gt; filter(continent == &quot;Europe&quot;) clist &lt;- filter(europe, gdpPercap&lt;10000 &amp; year==2007) lowincome_europe &lt;- filter(europe, country %in% clist$country) # grafiği çiz ggplot(lowincome_europe, aes(x = year, y = lifeExp, color = country)) + geom_line() Örnek: Avrupa’da 2007 yılındaki yaşam beklentisi küçükten büyüğe sıralayıp nokta grafiğini çiz. # önce verileri oluştur europe2007 &lt;- gapminder |&gt; filter(year == 2007, continent == &quot;Europe&quot;) # grafiği çiz ggplot(europe2007, aes(x = lifeExp, y = fct_reorder(country, lifeExp) # ülkeleri lifeEXp&#39;e göre sıraya diz )) + geom_point() + ylab(&quot;&quot;) + xlab(&quot;&quot;) + ggtitle(&quot;2007 yılında Avrupa ülkelerinde yaşam beklentisi&quot;) Alıştırma: yukarıdaki grafiğe 1952 yılının bilgisini ekleyerek bu dönemde yaşam beklentisinin nasıl değiştiğini görmek istiyorsunuz. Bu bilgiyi grafiğe nasıl eklersiniz? Örnek: Aşağıdaki veri setinin nokta+çizgi grafiğini çizelim. df &lt;- tibble(`yıl` = factor(c(2010, 2020, 2010, 2020)), x = c(100, 150, 200, 160), tip = factor(c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;))) df ## # A tibble: 4 × 3 ## yıl x tip ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 2010 100 A ## 2 2020 150 A ## 3 2010 200 B ## 4 2020 160 B df |&gt; ggplot(aes(`yıl`,x, color = tip, group=tip)) + geom_point() + geom_line() 2.5.13 Temalar ggplot2::theme() fonksiyonu ile grafiğimizin verilerle ilgili olmayan arkaplan, grid çizgileri, çerçeve çizgileri gibi özelliklerini değiştirebiliriz. Önceden tanımlanmış theme_bw(), theme_classic() gibi temaları kullanabiliriz Örnek olarak yukarıda oluşturduğumuz lowincome_europe grafiğini siyah-beyaz baskıya uygun hale getirelim: ggplot(lowincome_europe, aes(x = year, y = lifeExp, linetype = country # çizgi tipini ülkelere göre belirle )) + geom_line() + theme_bw() + # siyah-beyaz temayı kullan scale_x_continuous(breaks = seq(1952, 2007, 5)) + # x etiketlerini belirle theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) + # yönünü dikey yap xlab(&quot;&quot;) 2.5.14 Interaktif grafik İnteraktif serpilme çizimi için kullanabileceğimiz bir kütüphane {plotly}’dir. Detaylar için bkz https://plotly.com/r/getting-started/. library(plotly) # interaktif grafik için gerekli ## ## Attaching package: &#39;plotly&#39; ## The following object is masked from &#39;package:ggplot2&#39;: ## ## last_plot ## The following object is masked from &#39;package:stats&#39;: ## ## filter ## The following object is masked from &#39;package:graphics&#39;: ## ## layout library(gapminder) # veri seti p &lt;- gapminder |&gt; filter(year==2007) |&gt; ggplot( aes(gdpPercap, lifeExp, size = pop, color=continent)) + geom_point() + scale_x_log10() + theme_bw() ggplotly(p) İnteraktif kutu çizimleri: kutu_cizimi &lt;- plot_ly(gapminder, x = ~lifeExp, color = ~continent, type = &quot;box&quot;) kutu_cizimi R ile hemen hemen tüm grafikleri interaktif yapmak mümkündür. Detaylar için bkz https://www.r-graph-gallery.com/interactive-charts. 2.5.15 Harita çizimi R ile jeokonumsal verilerin görselleştirilmesinde çeşitli araçlar mevcuttur. {sf} (simple features) paketi: https://github.com/r-spatial/sf. ggplot2 fonksiyonları geom_sf() ve coord_sf() bu paket ile uyumlu çalışır. Örnek olarak Türkiye’nin il düzeyinde bir haritasını çizmek istediğimizi düşünelim. library(tidyverse) load(&quot;veriler/tr_harita_veri.RData&quot;) tr_harita_veri illerin sınırlarına ilişkin koordinat bilgisini içermektedir (geometry sütununda). İllerin isimlerinin yanı sıra geometry sütunu altında il sınır bilgileri yer almaktadır. Bu noktada il düzeyinde boş haritayı çizebiliriz: # boş il haritası ggplot(tr_harita_veri) + geom_sf() + coord_sf() geom_sf() fonksiyonu veri setinde yer alan geometry bilgisini kullanarak il sınırlarını koordinat sistemi üzerinde yerleştirdi. İstenirse harita üzerinde başka geometrik şekiller ile katmanlar eklenebilir. Örneğin, bazı şehir merkezlerini nokta ile işaretleyelim. Bunun için önce şehirlerin eylem-boylam bilgisini içeren bir tablo oluşturalım: tr_sehirler &lt;- tribble( ~city, ~lat, ~lon, &quot;Istanbul&quot;, 41.0, 29.0, &quot;Ankara&quot;, 39.9, 32.8, &quot;İzmir&quot;, 38.4, 27.1, &quot;Bursa&quot;, 40.2, 29.1, &quot;Antalya&quot;, 36.9, 30.7, &quot;Konya&quot;, 37.9, 32.5 ) # tr_sehirler içindeki şehirleri kırmızı nokta ile göster ggplot(tr_harita_veri) + geom_sf() + geom_point(data = tr_sehirler, mapping = aes(x = lon, y = lat), colour = &quot;red&quot;) + geom_text(data = tr_sehirler, mapping = aes(x = lon, y = lat, label = city), nudge_y = -0.15) + # y koordinatında şehir isimlerini aşağıya kaydır coord_sf() Başka bir versiyon: # sadece başkenti göster ggplot(tr_harita_veri) + geom_sf(color = &quot;black&quot;, fill = &quot;lightblue&quot;) + geom_point(aes(32.8, 39.9), color = &quot;red&quot;) + geom_text(aes(32.8, 40.2), label = &quot;Ankara&quot;) + coord_sf() + xlab(&quot;Boylam&quot;) + ylab(&quot;Enlem&quot;) + ggtitle(&quot;Türkiye&quot;) + theme_minimal() Harita üzerinde bölgelerin belirli bazı istatistiklerini renkler ve şekiller yardımıyla göstermek istersek bu bilgilerin bulunduğu veri setiyle geometri bilgisinin bulunduğu veri setini birleştirmemiz gerekir. Örnek olarak bkz tr_harita.R (R script klasöründe). Bu uygulamada tr_bolgesel_veri dosyasında bulunan bazı değişkenler harita üzerinde gösterilmektedir. 2.5.16 ggplot2 Uzantıları {patchwork}, {gganimate}, {ggthemes} vb çok sayıda eklenti geliştirilmiştir. Bu eklentileri incelemek için bkz. https://exts.ggplot2.tidyverse.org/gallery/ "],["2.6-forcats.html", "2.6 {forcats} Paketi ile Kategorik Değişkenlerin İşlenmesi", " 2.6 {forcats} Paketi ile Kategorik Değişkenlerin İşlenmesi R’da faktör değişkenleri belirli sayıda öğeleri olan karakter değişkenleridir. Tidyverse’in bir parçası olan {forcats} paketi bu tür değişkenlerin kolayca manipülasyonu için tasarlanmıştır. {forcats} içindeki fonksiyonlar fct_ ile başlar. Yaygın olarak kullanılan başlıca fonksiyonlar şunlardır: fct_reorder(): faktörleri bir başka değişkene göre yeniden sıralar. fct_infreq(): faktörlerin frekansına göre yeniden sıralar. fct_relevel(): faktörleri manuel olarak yeniden sıralar. fct_lump(): faktörleri sıklığına göre birleştirir. Örnek olarak {forcats} paketiyle gelen gss_cat veri setini düşünelim. library(tidyverse) # forcats otomatik olarak yüklenir library(forcats) # tek başına yüklemek istersek data(gss_cat) head(gss_cat) ## # A tibble: 6 × 9 ## year marital age race rincome partyid relig denom tvhours ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 2000 Never married 26 White $8000 to 9999 Ind,near rep Protes… Sout… 12 ## 2 2000 Divorced 48 White $8000 to 9999 Not str republican Protes… Bapt… NA ## 3 2000 Widowed 67 White Not applicable Independent Protes… No d… 2 ## 4 2000 Never married 39 White Not applicable Ind,near rep Orthod… Not … 4 ## 5 2000 Divorced 25 White Not applicable Not str democrat None Not … 1 ## 6 2000 Married 25 White $20000 - 24999 Strong democrat Protes… Sout… NA Faktör değişkenlerine daha yakından bakalım: str(gss_cat) ## tibble [21,483 × 9] (S3: tbl_df/tbl/data.frame) ## $ year : int [1:21483] 2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 ... ## $ marital: Factor w/ 6 levels &quot;No answer&quot;,&quot;Never married&quot;,..: 2 4 5 2 4 6 2 4 6 6 ... ## $ age : int [1:21483] 26 48 67 39 25 25 36 44 44 47 ... ## $ race : Factor w/ 4 levels &quot;Other&quot;,&quot;Black&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ rincome: Factor w/ 16 levels &quot;No answer&quot;,&quot;Don&#39;t know&quot;,..: 8 8 16 16 16 5 4 9 4 4 ... ## $ partyid: Factor w/ 10 levels &quot;No answer&quot;,&quot;Don&#39;t know&quot;,..: 6 5 7 6 9 10 5 8 9 4 ... ## $ relig : Factor w/ 16 levels &quot;No answer&quot;,&quot;Don&#39;t know&quot;,..: 15 15 15 6 12 15 5 15 15 15 ... ## $ denom : Factor w/ 30 levels &quot;No answer&quot;,&quot;Don&#39;t know&quot;,..: 25 23 3 30 30 25 30 15 4 25 ... ## $ tvhours: int [1:21483] 12 NA 2 4 1 NA 3 NA 0 3 ... Medeni durum bilgisine daha yakından bakalım: gss_cat |&gt; group_by(marital) |&gt; summarize(n=n()) |&gt; arrange(n) ## # A tibble: 6 × 2 ## marital n ## &lt;fct&gt; &lt;int&gt; ## 1 No answer 17 ## 2 Separated 743 ## 3 Widowed 1807 ## 4 Divorced 3383 ## 5 Never married 5416 ## 6 Married 10117 Divorced ve Separated gruplarının yeni bir isimle birleştirilmesi: gss_cat |&gt; mutate(marital = fct_recode(marital, &quot;Divorced/Separated&quot; = &quot;Separated&quot;, &quot;Divorced/Separated&quot; = &quot;Divorced&quot; ) ) |&gt; group_by(marital) |&gt; summarize(n=n()) |&gt; arrange(n) ## # A tibble: 5 × 2 ## marital n ## &lt;fct&gt; &lt;int&gt; ## 1 No answer 17 ## 2 Widowed 1807 ## 3 Divorced/Separated 4126 ## 4 Never married 5416 ## 5 Married 10117 Grupların sıklık grafiği: gss_cat |&gt; ggplot(aes(x = marital)) + geom_bar() gss_cat |&gt; mutate(marital = fct_infreq(marital)) |&gt; ggplot(aes(x = marital)) + geom_bar() + coord_flip() Başka bir yol gss_cat |&gt; group_by(marital) |&gt; summarize(n = n()) |&gt; ggplot(aes(x = fct_reorder(marital, n), y = n)) + geom_bar(stat = &quot;identity&quot;) + coord_flip() + xlab(&quot;&quot;) Daha fazla detay için bkz. https://r4ds.had.co.nz/factors.html ve https://forcats.tidyverse.org/. "],["2.7-stringr.html", "2.7 {stringr} Paketi ile Karakter Değişkenlerinin İşlenmesi", " 2.7 {stringr} Paketi ile Karakter Değişkenlerinin İşlenmesi {stringr} kütüphanesi karakter değişkenlerinin işlenmesi için tasarlanmış çeşitli fonksiyonlardan oluşur. Bu fonksiyonların hepsi str_ ile başlar (Console penceresinde str_ yazarak mevcut fonksiyonların listesini görebilirsiniz). Örneğin, str_length() bir string değişkeni içindeki karakter sayısını gösterir: str_length(c(&quot;R&quot;, &quot;Ekonometri&quot;, NA)) ## [1] 1 10 NA str_c() karakterleri birleştirir: karakter1 &lt;- &quot;R&quot; karakter2 &lt;- &quot;ile&quot; karakter3 &lt;- &quot;Regresyon Analizi&quot; str_c(karakter1, karakter2, karakter3) ## [1] &quot;RileRegresyon Analizi&quot; Arada boşluk bırakmadan birleştirildi. str_c(karakter1, karakter2, karakter3, sep = &quot; &quot;) ## [1] &quot;R ile Regresyon Analizi&quot; Bir karakter vektörünü tek bir stringe dönüştürmek için collapse opsiyonu kullanılabilir: kar1 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ç&quot;) kar1 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;ç&quot; str_c(kar1, collapse = &quot;-&quot;) ## [1] &quot;a-b-c-ç&quot; Karakterlerin bir alt kümesini almak için str_sub() kullanılabilir: kar2 &lt;- c(&quot;abc&quot;, &quot;defgh&quot;, &quot;ijklmno&quot;) # ilk iki karakteri al str_sub(kar2, 1, 2) ## [1] &quot;ab&quot; &quot;de&quot; &quot;ij&quot; # 3ncü karakter ve sonrakileri al str_sub(kar2, 3) ## [1] &quot;c&quot; &quot;fgh&quot; &quot;klmno&quot; # sondan ikiyi al (en sondan geriye say) str_sub(kar2, -2, -1) ## [1] &quot;bc&quot; &quot;gh&quot; &quot;no&quot; # elemanları büyük harf yap kar1 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ç&quot;, &quot;i&quot;) str_to_upper(kar1) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;Ç&quot; &quot;I&quot; Ç harfi doğru olarak büyük harfe dönüştürüldü ancak Türkçe’de I harfi yoktur. Bunun için locale = \"tr\" opsiyonu kullanılabilir. str_to_upper(kar1, locale = &quot;tr&quot;) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;Ç&quot; &quot;İ&quot; Ayrıca bkz. str_to_lower() ve str_to_title(). Karakterlerin alfabetik sıralanması sehirler &lt;- c(&quot;İstanbul&quot;, &quot;Ankara&quot;, &quot;Bursa&quot;, &quot;Adana&quot;, &quot;Zonguldak&quot;, &quot;Çanakkale&quot;) sehirler ## [1] &quot;İstanbul&quot; &quot;Ankara&quot; &quot;Bursa&quot; &quot;Adana&quot; &quot;Zonguldak&quot; &quot;Çanakkale&quot; str_sort(sehirler, locale = &quot;tr&quot;) ## [1] &quot;Adana&quot; &quot;Ankara&quot; &quot;Bursa&quot; &quot;Çanakkale&quot; &quot;İstanbul&quot; &quot;Zonguldak&quot; Bir ifadenin bulunması # sehirler vektöründe &quot;Adana&quot; var mı? str_detect(sehirler, &quot;Adana&quot;) ## [1] FALSE FALSE FALSE TRUE FALSE FALSE # Z ile başlıyor mu? str_detect(sehirler, &quot;Z&quot;) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE Aranan ifadenin pozisyonu str_which(sehirler, &quot;Zonguldak&quot;) ## [1] 5 str_split() fonksiyonu sehir_yil &lt;- c(&quot;Ankara-2020&quot;, &quot;İstanbul-2020&quot;, &quot;Ankara-2019&quot;, &quot;izmir-2019&quot;) sehir_yil ## [1] &quot;Ankara-2020&quot; &quot;İstanbul-2020&quot; &quot;Ankara-2019&quot; &quot;izmir-2019&quot; str_split(sehir_yil, pattern = &quot;-&quot;, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;Ankara&quot; &quot;2020&quot; ## [2,] &quot;İstanbul&quot; &quot;2020&quot; ## [3,] &quot;Ankara&quot; &quot;2019&quot; ## [4,] &quot;izmir&quot; &quot;2019&quot; Bir karakterin yerine başka bir karakterin yerleştirilmesi: Örnek olarak Türkçe harfler yerine İngilizce harfleri koymak istediğimizi düşünelim, yani ş yerine s, ı yerine i, vb. str_replace(&quot;Çanakkale&quot;, &quot;Ç&quot;, &quot;C&quot;) ## [1] &quot;Canakkale&quot; str_replace(c(&quot;Çanakkale&quot;, &quot;Çankırı&quot;), &quot;Ç&quot;, &quot;C&quot;) ## [1] &quot;Canakkale&quot; &quot;Cankırı&quot; Çok sayıda değişiklik yapacaksak: str_replace_all(c(&quot;Çanakkale&quot;, &quot;Çankırı&quot;), c(&quot;Ç&quot; = &quot;C&quot;, &quot;ı&quot; = &quot;i&quot;)) ## [1] &quot;Canakkale&quot; &quot;Cankiri&quot; Örnek: Bir karakter vektöründeki bütün Türkçe harfleri İngilizce harflerle değiştiren bir fonksiyon yazınız. # Replace Turkish characters with English characters # accepts a string vector # returns a string vector # requires stringr package tr_to_en &lt;- function(var){ newvar &lt;- stringr::str_replace_all(var, c(&quot;Ç&quot; = &quot;C&quot;, &quot;Ş&quot; = &quot;S&quot;, &quot;Ğ&quot; = &quot;G&quot;, &quot;İ&quot; = &quot;I&quot;, &quot;Ü&quot; = &quot;U&quot;, &quot;Ö&quot; = &quot;O&quot;, &quot;ç&quot; = &quot;c&quot;, &quot;ş&quot; = &quot;s&quot;, &quot;ğ&quot; = &quot;g&quot;, &quot;ı&quot; = &quot;i&quot;, &quot;ü&quot; = &quot;u&quot;, &quot;ö&quot; = &quot;o&quot;)) return(newvar) } tr_to_en(c(&quot;Çanakkale&quot;, &quot;Çankırı&quot;, &quot;Ağrı&quot;)) ## [1] &quot;Canakkale&quot; &quot;Cankiri&quot; &quot;Agri&quot; tr_to_en(sehirler) ## [1] &quot;Istanbul&quot; &quot;Ankara&quot; &quot;Bursa&quot; &quot;Adana&quot; &quot;Zonguldak&quot; &quot;Canakkale&quot; "],["2.8-lubridate.html", "2.8 {lubridate} Paketi ile Tarih-Zaman İşlemleri", " 2.8 {lubridate} Paketi ile Tarih-Zaman İşlemleri Tarih ve saat bilgisini içeren değişkenlerle işlem yapılmasında {lubridate} kütüphanesi kullanılabilir. Tarih ve saat değişkenlerinin oluşturulması Tarih (date) değişkeni: &lt;date&gt; Zaman (time) değişkeni: &lt;time&gt; Tarih-zaman (date-time) değişkeni: &lt;dttm&gt; library(tidyverse) library(lubridate) today() ## [1] &quot;2023-07-08&quot; now() ## [1] &quot;2023-07-08 23:00:58 +03&quot; Tarih-zaman değişkenleri karakter vektörlerinden hareketle oluşturulabilir. Örneğin # yıl-ay-gün ymd(&quot;2021/06,21&quot;) ## [1] &quot;2021-06-21&quot; # ay-gün-yıl mdy(&quot;6-21-2021&quot;) ## [1] &quot;2021-06-21&quot; # gün-ay-yıl dmy(&quot;21-06-2021&quot;) ## [1] &quot;2021-06-21&quot; Her örnekte çıktı yıl-ay-gün formatında bir date değişkenidir. class(dmy(&quot;21-06-2021&quot;)) ## [1] &quot;Date&quot; Tarih ve zaman değişkenleri oluşturma ymd_hms(&quot;2021-06-21 18:29:59&quot;, tz = &quot;GMT&quot;) ## [1] &quot;2021-06-21 18:29:59 GMT&quot; mdy_hm(&quot;06/21/2021 09:11&quot;) ## [1] &quot;2021-06-21 09:11:00 UTC&quot; Sys.timezone() ## [1] &quot;Europe/Istanbul&quot; # hms: hour-minute-second # UTC = Universal Coordinated Time Zone # GMT = Greenwich Mean Time (UTC ile aynı) # Türkiye: UTC +03 Bileşenlerden hareketle tarih oluşturma: make_date() fonksiyonu df &lt;- tibble(yıl = c(2018,2019,2020), # nümerik yıl ay = c(1,2,3), # nümerik ay gün = c(1,2,13) # nümerik gün ) df ## # A tibble: 3 × 3 ## yıl ay gün ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2018 1 1 ## 2 2019 2 2 ## 3 2020 3 13 df &lt;- df |&gt; mutate(tarih = make_date(yıl, ay, gün)) df ## # A tibble: 3 × 4 ## yıl ay gün tarih ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; ## 1 2018 1 1 2018-01-01 ## 2 2019 2 2 2019-02-02 ## 3 2020 3 13 2020-03-13 Gün bilgisini girmezsek 1 olarak oluşturulur: df |&gt; mutate(tarih = make_date(yıl, ay)) ## # A tibble: 3 × 4 ## yıl ay gün tarih ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; ## 1 2018 1 1 2018-01-01 ## 2 2019 2 2 2019-02-01 ## 3 2020 3 13 2020-03-01 Ayrıca bkz. make_datetime(). Bir date değişkenini bileşenlerine ayırma: year(df$tarih) ## [1] 2018 2019 2020 month(df$tarih) ## [1] 1 2 3 month(df$tarih, label = TRUE) ## [1] Jan Feb Mar ## Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; Oct &lt; Nov &lt; Dec mday(df$tarih) # day of the month ## [1] 1 2 13 yday(df$tarih) # day of the year ## [1] 1 33 73 wday(df$tarih) # day of the week ## [1] 2 7 6 wday(df$tarih, label = TRUE, abbr = FALSE) ## [1] Monday Saturday Friday ## Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; Friday &lt; Saturday Tarih verileriyle aritmetik: # gün ekle veya çıkar dmy(&quot;08-06-2021&quot;) + days(12) ## [1] &quot;2021-06-20&quot; dmy(&quot;08-06-2021&quot;) - days(12) ## [1] &quot;2021-05-27&quot; # yıl ekle veya çıkar dmy(&quot;08-06-2021&quot;) + years(2) ## [1] &quot;2023-06-08&quot; dmy(&quot;08-06-2021&quot;) - years(1) ## [1] &quot;2020-06-08&quot; # ay ekle veya çıkar dmy(&quot;08-06-2021&quot;) + months(2) ## [1] &quot;2021-08-08&quot; dmy(&quot;08-06-2021&quot;) - months(1) ## [1] &quot;2021-05-08&quot; Zaman farkı: (difftime) fark &lt;- dmy(&quot;08-06-2021&quot;)-dmy(&quot;08-06-2018&quot;) fark ## Time difference of 1096 days # saniye cinsinden süre as.duration(fark) ## [1] &quot;94694400s (~3 years)&quot; Sürelerle ilgili daha detaylı bilgi için bkz. https://r4ds.had.co.nz/dates-and-times.html "],["3-Kesit.html", " 3 Regresyon Analizi: Kesit Veri", " 3 Regresyon Analizi: Kesit Veri Bu kısımda ekonometrik analizin temelini oluşturan regresyon analizine giriş yapılacaktır. Bu kısımda yararlanılan başlıca kaynaklar: Wooldridge, J. (2019), Introductory Econometrics, 7th ed, Cengage Learning. R uygulamaları: Heiss, F. (2016), Using R for Introductory Econometrics, CreateSpace Independent Publishing Platform. URL: http://www.urfie.net/ Stock, J. and Watson, M. (2015), Introduction to Econometrics, Third Update, Global Edition, Pearson Education Limited. R uygulamaları: https://www.econometrics-with-r.org/index.html Kleiber, C. and Zeileis, A. (2008), Applied Econometrics with R, Springer. URL: https://www.zeileis.org/teaching/AER/ "],["3.1-ekonometriye-giriş.html", "3.1 Ekonometriye Giriş", " 3.1 Ekonometriye Giriş Ekonometri kelime anlamıyla ekonomik ölçme demektir. Ancak, ekonometrinin ugraşı alanı çok daha geniştir. “Ekonometri, ekonomik olayların ekonomik teori, matematik ve istatistiksel çıkarım (inference) araçlarıyla analiz edildiği bir sosyal bilimdir.” (Goldberger, A.S., 1964). Ekonometrinin uğraşı alanları Ekonomik ilişkilerin tahmini için istatistiksel yöntemler geliştirmek, Ekonomik teori ve hipotezleri test etmek, Ekonomi politikalarını değerlendirmek ve uygulamak, Tahmin-Öngörü- (forecasting) yapmak, Deneysel-olmayan (nonexperimental) ya da gözlemsel (observational) veri (data) toplamak ve analiz etmek. "],["3.2-veri-türleri.html", "3.2 Veri Türleri", " 3.2 Veri Türleri Kesitler-arası veri (cross-sectional data): Kişiler, tüketiciler, hane halkları, firmalar, bölgeler, ülkeler gibi mikro birimlere ait zamanın belli bir noktasında gözlemlenen verileri kapsar. Zaman serisi verileri (time series data): Birbirine eşit zaman aralıklarında (günlük, aylık, haftalık, yıllık vb.) gözlemlenen verileri kapsar. GDP, enflasyon oranı, faiz haddi, borsa indeksi gibi birçok makroekonomik ve finansal değişkenler bu gruba girer. Birleştirilmiş Kesitler-arası veri (pooled cross-section): Farklı zamanlarda gözlemlenerek birleştirilmiş kesitler-arası verileri kapsar. Örneğin hanehalkı işgücü anketleri Panel Veri (panel data, longitudinal data): Farklı zamanlarda aynı mikro birimlerin gözlemlenmesiyle oluşturulmuş verileri kapsar. "],["3.3-basit-regresyon-modeli.html", "3.3 Basit Regresyon Modeli", " 3.3 Basit Regresyon Modeli Tek açıklayıcı değişkenli (basit) regresyon modeli \\[y = \\beta_0 + \\beta_1 x + u\\] olarak yazılabilir. Burada \\(y\\): bağımlı değişken \\(x\\): açıklayıcı değişken \\(u\\): rassal (tesadüfi) hata terimidir. Rassal Hata Terimi: \\(u\\) (Error term - Disturbance term), Bağımlı değişken \\(y\\) üzerinde etkili olan \\(x\\)’in dışındaki diğer faktörleri (modelde yer almayan olası tüm değişkenler) temsil eder. Bu diğer etkenlere gözlenemeyen (unobserved) faktörler denir. Eğer \\(u\\)’da yer alan diğer faktörler sabit tutulursa, yani \\(\\Delta u = 0\\) kabul edilirse \\(x\\)’in \\(y\\) üzerindeki etkisi aşağıdaki gibi bulunabilir: \\[ \\Delta y = \\beta_1 \\Delta x\\] Eğim katsayısı \\(\\beta_1\\): Diğer faktörler sabitken (ceteris paribus) \\(x\\)’deki bir birim değişmenin \\(y\\)’de yaratacağı değişimi gösterir. Sabit terim (intercept) \\(\\beta_0\\): \\(x=0\\) iken \\(y\\)’nin alacağı değeri gösterir. Örnek: Eğitim düzeyi ve saatlik ücretler \\[ ücret = \\beta_0 + \\beta_1 eğitim + u\\] ücret: saat başına ücretler (dolar); eğitim: eğitim düzeyi (yıl) Eğim Katsayısı \\(\\beta_1\\)’in yorumu \\[\\Delta ücret = \\beta_1 \\Delta eğitim\\] Ceteris Paribus eğitim düzeyindeki 1 yıllık değişim, saat başına ücretleri ortalamada \\(\\beta_1\\) $ kadar değiştirir. Rassal hata terimi \\(u\\): Ücretleri etkileyen eğitim dışındaki diğer tüm gözlenemeyen faktörleri temsil eder. Emek piyasasındaki tecrübe (yıl), doğuştan gelen yetenek, şu an çalışılan yerdeki kıdem, iş etiği, alınan eğitimin kalitesi, çalışanın cinsiyeti, etnik kökeni, kır ya da kente yaşaması, medeni hali, çocuk sayısı, dış görünüşü vs. gibi çok sayıda faktör ücretleri etkileyebilir. "],["3.4-popülasyon-regresyon-fonksiyonu.html", "3.4 Popülasyon Regresyon Fonksiyonu", " 3.4 Popülasyon Regresyon Fonksiyonu Basit regresyon modelinde \\(y\\)’nin \\(x\\)’e göre koşullu beklenen değerini alalım: \\[\\begin{aligned}E(y|x) &amp; = \\beta_0 + \\beta_1 x + \\underbrace{E(u|x)}_{=0} \\\\ &amp; = \\beta_0 + \\beta_1 x \\end{aligned}\\] Buna PRF adı verilir. Açıktır ki, bağımlı değişkenin koşullu beklenen değeri \\(x\\)’in doğrusal bir fonksiyonudur. PRF’nin doğrusallığı: \\(x\\)’deki 1 birimlik değişime karşılık \\(y\\)’nin koşullu beklenen değeri (koşullu ortalaması) \\(\\beta_1\\) kadar değişmektedir. Verilmiş bir \\(x\\) düzeyinde \\(y\\)’nin dağılımının merkezi \\(E(y|x)\\)’dir. "],["3.5-sıradan-en-küçük-kareler-ekk-yöntemi-ile-tahmin.html", "3.5 (Sıradan) En Küçük Kareler (EKK) Yöntemi ile Tahmin", " 3.5 (Sıradan) En Küçük Kareler (EKK) Yöntemi ile Tahmin Bilinmeyen popülasyon parametreleri ( \\(\\beta_0,\\beta_1\\) ) verilerden hareketle nasıl tahmin edilebilir? Popülasyondan \\(n\\) gözlemli (hacimli) bir rassal örneklem (random sample) çektiğimizi düşünelim: \\[\\{y_i,x_i:i=1,2,\\ldots,n\\}\\] Regresyon modelini herbir gözlem için aşağıdaki gibi yazabiliriz: \\[y_i = \\beta_0 + \\beta_1 x_i + u_i,~~~i=1,2,\\ldots,n\\] Bu durumda elimizde iki bilinmeyenli \\(n\\) denklem olacaktır. Gözlemlerle endekslenmiş model: \\[y_i = \\beta_0 + \\beta_1 x_i + u_i,~~~i=1,2,\\ldots,n\\] İki bilinmeyenli \\(n\\) denklem: \\[\\begin{eqnarray*}y_1 &amp;=&amp; \\beta_0 + \\beta_1 x_1 + u_1 \\\\ y_2 &amp;=&amp; \\beta_0 + \\beta_1 x_2 + u_2 \\\\ y_3 &amp;=&amp; \\beta_0 + \\beta_1 x_3 + u_3 \\\\ \\vdots &amp;=&amp; \\vdots \\\\ y_n &amp;=&amp; \\beta_0 + \\beta_1 x_n + u_n \\end{eqnarray*}\\] \\(y\\)’nin modelce tahmin edilen değerleri (fitted values): \\[\\hat{y}_i = \\hat{\\beta}_0 + \\hat{\\beta}_1 x_i\\] Kalıntı (residual) terimleri gözlenen ile tahmin edilen \\(y\\) değerleri arasındaki farktır: \\[\\begin{eqnarray*}\\hat{u}_i &amp;=&amp; y_i - \\hat{y}_i \\\\ &amp;=&amp; y_i - \\hat{\\beta}_0 - \\hat{\\beta}_1 x_i \\end{eqnarray*}\\] Kalıntı terimi, hata terimi ile karıştırılmamalıdır. \\(u\\) gözlenemeyen bir rassal değişkendir. \\(\\hat{u}\\) ise modelce tahmin edilen bir büyüklüktür. OLS-SEKK amaç fonksiyonu: OLS (OLS = Ordinary Least Squares) yöntemi kalıntı kareleri toplamını en küçük yapacak şekilde tahmincileri seçer: \\[\\min_{\\hat{\\beta}_0, \\hat{\\beta}_1} SSR = \\sum_{i=1}^n \\hat{u}_i^2=\\sum_{i=1}^n(y_i - \\hat{\\beta}_0 - \\hat{\\beta}_1 x_i)^2\\] OLS yöntemi kalıntı kareleri toplamını (SSR) en küçük yapacak şekilde tahmincileri seçer: \\[\\min_{\\hat{\\beta}_0, \\hat{\\beta}_1} SSR = \\sum_{i=1}^n (y_i - \\hat{\\beta}_0 - \\hat{\\beta}_1 x_i)^2\\] OLS birinci sıra koşulları \\[\\begin{eqnarray*} \\frac{\\partial SSR}{\\partial \\hat{\\beta}_0 } &amp;=&amp; -2 \\sum_{i=1}^n (y_i - \\hat{\\beta}_0 - \\hat{\\beta}_1 x_i) = 0 \\\\ \\frac{\\partial SSR}{\\partial \\hat{\\beta}_1 } &amp;=&amp; -2 \\sum_{i=1}^n x_i(y_i - \\hat{\\beta}_0 - \\hat{\\beta}_1 x_i) = 0 \\end{eqnarray*}\\] Birinci sıra koşullarından elde edilen iki bilinmeyenli iki denklemli sistem belirli şartlar altında çözülebilir. "],["3.6-popülasyon-ve-örneklem-regresyon-fonksiyonları.html", "3.6 Popülasyon ve Örneklem Regresyon Fonksiyonları", " 3.6 Popülasyon ve Örneklem Regresyon Fonksiyonları Popülasyon Regresyon Fonksiyonu - PRF (pratikte bilinmez) \\[E(y|x) = \\beta_0 + \\beta_1 x\\] Örneklem Regresyon Fonksiyonu (Sample Regression Function - SRF) \\[\\hat{y} = \\hat{\\beta}_0 + \\hat{\\beta}_1 x\\] SRF, PRF’nin bir tahmini olarak düşünülebilir. SRF verilere bağlı olarak değişir. Eğim katsayısının yorumu: \\[\\hat{\\beta}_1 = \\frac{\\Delta \\hat{y}}{\\Delta x}\\] ya da \\[\\Delta \\hat{y} = \\hat{\\beta}_1 \\Delta x\\] "],["3.7-fonksiyon-kalıpları.html", "3.7 Fonksiyon kalıpları", " 3.7 Fonksiyon kalıpları 3.7.1 Regresyon modelinin doğrusallığı \\[y = \\beta_0 + \\beta_1 x + u\\] \\(y\\): bağımlı değişken, - \\(x\\): açıklayıcı değişken Doğrusallık varsayımı bazı durumlarda kısıtlayıcı olabilir. Değişkenlerin uygun dönüştürmelerini kullanarak bu doğrusal olmayan ilişkileri yakalayabiliriz. Bu durumda model hala parametrelerde doğrusal olacaktır. En yaygın kullanılan dönüştürmeler (doğal) logaritma dönüştürmesi, karesel veya kübik terimler (genel olarak polinomlar), ters kalıp, vb. 3.7.2 Doğrusal olmama Kırmızı çizgi: tahmin edilen regresyon doğrusu. Hangi modeller uygun? 3.7.3 Log-level Orijinal model: \\(y = \\exp(\\beta_0 + \\beta_1 x + u)\\) Doğal logaritma dönüştürmesi: \\(\\log y = \\beta_0 + \\beta_1 x + u\\) \\(\\beta_1\\)’in yorumu: \\(x\\) değişkenindeki 1 birim değişime karşılık \\(y\\)’de tahmin edilen değişim \\(\\%(100\\beta_1)\\)’dir. Not: \\(100\\Delta\\log y = \\%\\Delta y\\) 3.7.4 Level-log Dönüştürülmüş model: \\(y = \\beta_0 + \\beta_1 \\log x + u\\) \\(\\beta_1\\)’in yorumu: \\(x\\)’deki %1 değişime karşılık \\(y\\)’de tahmin edilen değişim \\((\\beta_1/100)\\) birimdir ( \\(y\\)’nin ölçü birimi cinsinden). 3.7.5 Log-log (Sabit esneklik modeli) Dönüştürülmüş model: \\(\\log y = \\beta_0 + \\beta_1 \\log x + u\\) \\(\\beta_1\\)’in yorumu: \\(x\\)’deki %1 değişime karşılık \\(y\\)’de tahmin edilen değişim % \\(\\beta_1\\) kadardır. \\(\\beta_1\\) = \\(y\\)’nin \\(x\\)’e göre esnekliği. "],["3.8-çoklu-regresyon-modeli.html", "3.8 Çoklu Regresyon Modeli", " 3.8 Çoklu Regresyon Modeli Basit regresyon modelinde sadece bir \\(x\\) değişkeni vardır. Bu çoğu durumda gerçekçi değildir. \\(y\\)’yi etkileyen çok sayıda önemli faktör vardır. Modele teorik açıdan önemli değişkenler ekleyerek \\(y\\)’deki değişkenliğin çok daha fazlasını açıklayabiliriz. Ayrıca daha esnek fonksiyon kalıplarını kullanabiliriz. En genel haliyle çoklu regresyon modeli aşağıdaki gibi yazılabilir. \\[ y= \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\ldots + \\beta_k x_k + u\\] Modelde \\(k\\) \\(x\\) değişkeni ve bir sabit terim (kesme terimi) mevcuttur. Bilinmeyen parametre sayısı \\(k+1\\)’dir. \\(\\beta_j\\) parametresi diğer \\(x\\)’ler ve \\(u\\)’da içerilen faktörler sabitken ( \\(\\Delta u=0\\) ), \\(x_j\\)’deki bir birimlik değişmenin \\(y\\)’de yaratacağı değişmeyi gösterir. Ancak \\(x\\)’ler arasında doğrusal olmayan özellik varsa bu yorum değişir. Örneklem Regresyon Fonksiyonu (SRF): \\[\\hat{y} = \\hat{\\beta}_0 + \\hat{\\beta}_1 x_1 + \\hat{\\beta}_2 x_2 + \\ldots + \\hat{\\beta}_k x_k\\] Sıradan En Küçük Kareler (Ordinary Least Squares - OLS) tahmin edicileri kalıntı kareleri toplamını (SSR) en küçük yapar: \\[\\sum_{i=1}^n \\hat{u}_i^2 = \\sum_{i=1}^n (y_i - \\hat{\\beta}_0 - \\hat{\\beta}_1 x_{i1} - \\hat{\\beta}_2 x_{i2} - \\ldots - \\hat{\\beta}_k x_{ik})^2\\] Birinci sıra koşullarından elde edilen \\(k+1\\) denklemin çözümünden OLS tahmin edicileri \\(\\hat{\\beta}_j\\)’ler bulunur. R programındaki lm() fonksiyonu ile model kolayca tahmin edilebilir. "],["3.9-r-lm-fonksiyonu.html", "3.9 R lm() Fonksiyonu", " 3.9 R lm() Fonksiyonu Syntax: lm(formula = y ~ x1 + x2 + ... + xk, data = veri_ismi) Burada veri_ismi değişkenlerin yer aldığı veri çerçevesinin ismidir. library(wooldridge) # veri paketi # veri seti = wage1 reg1 &lt;- lm(wage ~ educ, data = wage1) reg1 ## ## Call: ## lm(formula = wage ~ educ, data = wage1) ## ## Coefficients: ## (Intercept) educ ## -0.9049 0.5414 Modele sabit terim otomatik olarak eklenir. Eğer modelden sabiti çıkarmak istersek: lm(y ~ 0 + x1 + x2 + ... + xk, data = df_ismi) Çok değişkenli log-level ücret regresyonu: reg2 &lt;- lm(log(wage) ~ educ + exper + tenure, data = wage1) summary(reg2) ## ## Call: ## lm(formula = log(wage) ~ educ + exper + tenure, data = wage1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.05802 -0.29645 -0.03265 0.28788 1.42809 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.284360 0.104190 2.729 0.00656 ** ## educ 0.092029 0.007330 12.555 &lt; 2e-16 *** ## exper 0.004121 0.001723 2.391 0.01714 * ## tenure 0.022067 0.003094 7.133 3.29e-12 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4409 on 522 degrees of freedom ## Multiple R-squared: 0.316, Adjusted R-squared: 0.3121 ## F-statistic: 80.39 on 3 and 522 DF, p-value: &lt; 2.2e-16 # reg2 (liste) nesnesi regresyon sonuçlarına ilişkin bilgileri içerir # summary() fonksiyonu ile özet bilgilere ulaşılabilir summary(reg2)$coefficients ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.284359555 0.104190378 2.729230 6.562462e-03 ## educ 0.092028987 0.007329923 12.555246 8.824204e-32 ## exper 0.004121109 0.001723277 2.391437 1.713562e-02 ## tenure 0.022067217 0.003093649 7.133070 3.294408e-12 Veri setinin bir alt kümesi için regresyonun çözümü # Kadın çalışanlar için ücret denklemi tahmini reg_K &lt;- lm(log(wage) ~ educ + exper + tenure, data = wage1, subset = (female==1) # female=1 kadın, female=0 erkek ) summary(reg_K) ## ## Call: ## lm(formula = log(wage) ~ educ + exper + tenure, data = wage1, ## subset = (female == 1)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.96850 -0.23365 -0.06671 0.21956 1.17698 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.356116 0.141063 2.525 0.0122 * ## educ 0.080036 0.010462 7.650 4.44e-13 *** ## exper 0.002268 0.002105 1.077 0.2823 ## tenure 0.010274 0.005223 1.967 0.0503 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3967 on 248 degrees of freedom ## Multiple R-squared: 0.2119, Adjusted R-squared: 0.2024 ## F-statistic: 22.23 on 3 and 248 DF, p-value: 8.771e-13 # Erkek çalışanlar için ücret denklemi tahmini reg_E &lt;- lm(log(wage) ~ educ + exper + tenure, data = wage1, subset = (female==0) # female=1 kadın, female=0 erkek ) summary(reg_E) ## ## Call: ## lm(formula = log(wage) ~ educ + exper + tenure, data = wage1, ## subset = (female == 0)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.4849 -0.2784 -0.0103 0.2665 1.2670 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.321899 0.139460 2.308 0.02174 * ## educ 0.096264 0.009352 10.294 &lt; 2e-16 *** ## exper 0.008127 0.002496 3.256 0.00128 ** ## tenure 0.018213 0.003769 4.832 2.27e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4284 on 270 degrees of freedom ## Multiple R-squared: 0.3655, Adjusted R-squared: 0.3584 ## F-statistic: 51.84 on 3 and 270 DF, p-value: &lt; 2.2e-16 Sonuçları özetleme ve tablo oluşturma: stargazer paketi # Örnek library(stargazer) stargazer(list(reg2, reg_K, reg_E), type=&quot;text&quot;,keep.stat=c(&quot;n&quot;,&quot;rsq&quot;)) ## ## ========================================== ## Dependent variable: ## ----------------------------- ## log(wage) ## (1) (2) (3) ## ------------------------------------------ ## educ 0.092*** 0.080*** 0.096*** ## (0.007) (0.010) (0.009) ## ## exper 0.004** 0.002 0.008*** ## (0.002) (0.002) (0.002) ## ## tenure 0.022*** 0.010* 0.018*** ## (0.003) (0.005) (0.004) ## ## Constant 0.284*** 0.356** 0.322** ## (0.104) (0.141) (0.139) ## ## ------------------------------------------ ## Observations 526 252 274 ## R2 0.316 0.212 0.365 ## ========================================== ## Note: *p&lt;0.1; **p&lt;0.05; ***p&lt;0.01 Sonuçları özetleme ve tablo oluşturma: modelsummary paketi library(modelsummary) models &lt;- list(&quot;Tüm Örneklem&quot; = reg2, &quot;Kadınlar&quot; = reg_K, &quot;Erkekler&quot;=reg_E) modelsummary(models) Tüm Örneklem Kadınlar Erkekler (Intercept) 0.284 0.356 0.322 (0.104) (0.141) (0.139) educ 0.092 0.080 0.096 (0.007) (0.010) (0.009) exper 0.004 0.002 0.008 (0.002) (0.002) (0.002) tenure 0.022 0.010 0.018 (0.003) (0.005) (0.004) Num.Obs. 526 252 274 R2 0.316 0.212 0.365 R2 Adj. 0.312 0.202 0.358 AIC 2344.8 969.0 1312.8 BIC 2366.1 986.7 1330.9 Log.Lik. −313.548 −122.587 −154.491 F 80.391 22.233 51.836 RMSE 0.44 0.39 0.43 Robust standart hatalar: # vcov = c(&quot;classical&quot;, &quot;robust&quot;, &quot;bootstrap&quot;, &quot;stata&quot;, &quot;HC4&quot;) # detaylar için bkz sandwich paketi modelsummary(models, vcov = &quot;robust&quot;) Tüm Örneklem Kadınlar Erkekler (Intercept) 0.284 0.356 0.322 (0.113) (0.190) (0.153) educ 0.092 0.080 0.096 (0.008) (0.015) (0.010) exper 0.004 0.002 0.008 (0.002) (0.002) (0.003) tenure 0.022 0.010 0.018 (0.004) (0.006) (0.005) Num.Obs. 526 252 274 R2 0.316 0.212 0.365 R2 Adj. 0.312 0.202 0.358 AIC 2344.8 969.0 1312.8 BIC 2366.1 986.7 1330.9 Log.Lik. −313.548 −122.587 −154.491 F 65.799 12.190 46.887 RMSE 0.44 0.39 0.43 Std.Errors HC3 HC3 HC3 # istatistiksel anlamlılık için yıldız ekleme modelsummary(models, vcov = &quot;robust&quot;, stars = TRUE) Tüm Örneklem Kadınlar Erkekler (Intercept) 0.284* 0.356+ 0.322* (0.113) (0.190) (0.153) educ 0.092*** 0.080*** 0.096*** (0.008) (0.015) (0.010) exper 0.004* 0.002 0.008** (0.002) (0.002) (0.003) tenure 0.022*** 0.010 0.018*** (0.004) (0.006) (0.005) Num.Obs. 526 252 274 R2 0.316 0.212 0.365 R2 Adj. 0.312 0.202 0.358 AIC 2344.8 969.0 1312.8 BIC 2366.1 986.7 1330.9 Log.Lik. −313.548 −122.587 −154.491 F 65.799 12.190 46.887 RMSE 0.44 0.39 0.43 Std.Errors HC3 HC3 HC3 + p &lt; 0.1, * p &lt; 0.05, ** p &lt; 0.01, *** p &lt; 0.001 Kullanım klavuzu ve detaylı örnekler için bkz. https://vincentarelbundock.github.io/modelsummary/articles/modelsummary.html "],["3.10-kukla-kategorik-değişkenler.html", "3.10 Kukla (kategorik) değişkenler", " 3.10 Kukla (kategorik) değişkenler Regresyon modellerinde niteliksel bilgiyi içeren kategorik değişkenleri ekleyebiliriz. İki kategori, cinsiyet = Kadın, Erkek \\[x_{i}=\\left\\{\\begin{array}{ll} 1, &amp; \\text { eğer } i . \\text { kişi kadın ise } \\\\ 0, &amp; \\text { eğer } i . \\text { kişi erkek ise. } \\end{array}\\right.\\] \\[y_{i}=\\beta_{0}+\\beta_{1} x_{i}+\\epsilon_{i}=\\left\\{\\begin{array}{ll} \\beta_{0}+\\beta_{1}+\\epsilon_{i}, &amp; \\text { eğer } i . \\text { kişi kadın ise } \\\\ \\beta_{0}+\\epsilon_{i}, &amp; \\text { eğer } i . \\text { kişi erkek ise. } \\end{array}\\right.\\] \\(\\beta_0\\): erkek grubu için regresyon kesme noktası (sabit) \\(\\beta_{0}+\\beta_{1}\\): kadın grubu için kesme noktası İki kategori için bir kukla değişken eklemek yeterli. İkiden fazla kategorisi olan değişkenler için bir eksiği kadar kukla değişken modele eklenebilir. Örneğin etnik köken değişkeni 3 gruba sahipse, modele 2 kategoriyi temsil eden kukla değişkenin eklenmesi yeterlidir. Dışlanan grup kesme terimi ile temsil edilir (baz grup). Ücretlerin cinsiyet (female = 1 kadın ise, female = 0 erkek ise) kuklası üzerine regresyonu res1 &lt;- lm(wage ~ female, data = wage1) summary(res1) ## ## Call: ## lm(formula = wage ~ female, data = wage1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.5995 -1.8495 -0.9877 1.4260 17.8805 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 7.0995 0.2100 33.806 &lt; 2e-16 *** ## female -2.5118 0.3034 -8.279 1.04e-15 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.476 on 524 degrees of freedom ## Multiple R-squared: 0.1157, Adjusted R-squared: 0.114 ## F-statistic: 68.54 on 1 and 524 DF, p-value: 1.042e-15 \\[\\widehat{wage} = 7.1 - 2.51 female\\] Baz grup (0 grubu) erkek çalışanlardır. Buna göre erkek çalışanların sabit terimi 7.1’dir. Kadın çalışanların (female=1) sabit terimi erkeklerden 2.51 USD daha düşüktür (4.5$) Modelde başka bir x değişkeni olmadığı için 7.1 erkek grubundaki aritmetik ortalamadır. Kadın grubundaki aritmetik ortalama ise 4.5$’dır. Tahmin sonuçları res2 &lt;- lm(log(wage) ~ female + educ, data = wage1) summary(res2) ## ## Call: ## lm(formula = log(wage) ~ female + educ, data = wage1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.02672 -0.27470 -0.03731 0.26219 1.34738 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.826269 0.094054 8.785 &lt;2e-16 *** ## female -0.360865 0.039024 -9.247 &lt;2e-16 *** ## educ 0.077203 0.007047 10.955 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4455 on 523 degrees of freedom ## Multiple R-squared: 0.3002, Adjusted R-squared: 0.2975 ## F-statistic: 112.2 on 2 and 523 DF, p-value: &lt; 2.2e-16 \\[\\widehat{\\log wage} = 0.83 - 0.36 female + 0.077educ\\] Baz grup (0 grubu) erkek çalışanlardır. Buna göre erkek çalışanların sabit terimi 0.83’dir. Kadın çalışanların (female=1) sabit terimi erkeklerden 0.36 daha düşüktür (0.47). Educ değişkeninin katsayısı 0.077 her iki grup için de aynıdır. Yani bir yıllık fazladan eğitimin getirisi hem kadınlar için hem de erkekler için % 7.7’dir. Eğitim düzeyi aynı olan bir erkek ve kadını karşılaştırdığımızda kadınlar hala daha az kazanıyor. "],["3.11-etkileşim-değişkenleri.html", "3.11 Etkileşim değişkenleri", " 3.11 Etkileşim değişkenleri Bazı durumlarda bir değişkenin marjinal etkisi başka bir değişkene bağlı olabilir. Örneğin satış ve reklam harcamaları modelinde radyo ilan harcamaları TV reklamlarının etkisi arttırabilir. \\[sales = \\beta_{0}+\\beta_{1}~ TV+\\beta_{2}~ Radio + \\beta_3~ (TV\\times Radio) + \\epsilon\\] ya da \\[sales = \\beta_{0}+(\\beta_{1}+\\beta_3 Radio)~ TV+\\beta_{2}~ Radio + \\epsilon\\] Böylece \\[\\frac{\\Delta Sales}{\\Delta TV}=\\beta_{1}+\\beta_3 Radio,\\quad \\frac{\\Delta Sales}{\\Delta Radio}=\\beta_{2}+\\beta_3 TV\\] Örnek 1 Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 6.7502 0.2479 27.2328 0.0000 TV 0.0191 0.0015 12.6990 0.0000 radio 0.0289 0.0089 3.2408 0.0014 I(TV * radio) 0.0011 0.0001 20.7266 0.0000 TV, radio: USD cinsinden televizyon ve radyo reklam harcamaları, Radyo reklamlarındaki 1000 dolarlık bir artış için satışlarda ortalamada ne kadar değişim tahmin edilmiştir? \\(\\Delta Sales = (0.0289+0.0011TV)\\times 1000 = 28.9 + 1.1TV\\) Ortalama TV harcamaları 147. Bunu TV yerine yazarsak ortalamadaki etkiyi 190.6 USD olarak buluruz. Örnek: Eğitimin getirisi kadın ve erkeklerde farklı mı? res3 &lt;- lm(log(wage) ~ educ + exper + tenure + female + I(female*educ), data = wage1) summary(res3) ## ## Call: ## lm(formula = log(wage) ~ educ + exper + tenure + female + I(female * ## educ), data = wage1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.91695 -0.26530 -0.02059 0.25715 1.27586 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.464712 0.122892 3.781 0.000174 *** ## educ 0.090276 0.008715 10.359 &lt; 2e-16 *** ## exper 0.004642 0.001628 2.850 0.004541 ** ## tenure 0.017436 0.002981 5.849 8.76e-09 *** ## female -0.210376 0.173969 -1.209 0.227107 ## I(female * educ) -0.007245 0.013562 -0.534 0.593456 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4162 on 520 degrees of freedom ## Multiple R-squared: 0.3926, Adjusted R-squared: 0.3868 ## F-statistic: 67.22 on 5 and 520 DF, p-value: &lt; 2.2e-16 Başka bir yol res4 &lt;- lm(log(wage) ~ educ*female + exper + tenure, data = wage1) summary(res4) ## ## Call: ## lm(formula = log(wage) ~ educ * female + exper + tenure, data = wage1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.91695 -0.26530 -0.02059 0.25715 1.27586 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.464712 0.122892 3.781 0.000174 *** ## educ 0.090276 0.008715 10.359 &lt; 2e-16 *** ## female -0.210376 0.173969 -1.209 0.227107 ## exper 0.004642 0.001628 2.850 0.004541 ** ## tenure 0.017436 0.002981 5.849 8.76e-09 *** ## educ:female -0.007245 0.013562 -0.534 0.593456 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4162 on 520 degrees of freedom ## Multiple R-squared: 0.3926, Adjusted R-squared: 0.3868 ## F-statistic: 67.22 on 5 and 520 DF, p-value: &lt; 2.2e-16 Bu örnek için bkz. James et al. (2021, s.89) An Introduction to Statistical Learning with Applications in R, https://www.statlearning.com/↩︎ "],["3.12-karesel-ve-polinom-terimler.html", "3.12 Karesel ve polinom terimler", " 3.12 Karesel ve polinom terimler Modelin parametrelerde doğrusal olan yapısını bozmadan \\(y\\) ve \\(x\\) değişkenlerinin uygun dönüştürmelerini kullanarak doğrusal olmayan ilişkileri yakalayabiliriz. Pratikte en çok kullanılan dönüştürmeler (doğal) logaritma ve üstel dönüştürmelerdir. Bu modellerin özelliklerini daha önce incelemiştik. Polinom regresyonu: \\(X\\) değişkeninin \\(X^2\\) ve \\(X^3\\) gibi dönüştürmelerini modele ekleyebiliriz. Örneğin karesel model: \\[Y = \\beta_0 + \\beta_1 X + \\beta_2 X^2 + \\epsilon\\] Bu model aslında \\(X\\) değişkeninin kendisiyle etkileşim içinde olduğu anlamına gelir. \\(X\\)’in \\(Y\\) üzerindeki etkisi \\(X\\)’in değerine bağlıdır. Örnek: ücret denkleminde tecrübe ve tenure karesini ekleme: res5 &lt;- lm(log(wage) ~ educ + exper + tenure + female + I(female*educ) + I(exper^2) + I(tenure^2), data = wage1) summary(res5) ## ## Call: ## lm(formula = log(wage) ~ educ + exper + tenure + female + I(female * ## educ) + I(exper^2) + I(tenure^2), data = wage1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.83265 -0.25261 -0.02374 0.25396 1.13584 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.3888060 0.1186871 3.276 0.00112 ** ## educ 0.0823692 0.0084699 9.725 &lt; 2e-16 *** ## exper 0.0293366 0.0049842 5.886 7.11e-09 *** ## tenure 0.0318967 0.0068640 4.647 4.28e-06 *** ## female -0.2267886 0.1675394 -1.354 0.17644 ## I(female * educ) -0.0055645 0.0130618 -0.426 0.67028 ## I(exper^2) -0.0005804 0.0001075 -5.398 1.03e-07 *** ## I(tenure^2) -0.0005900 0.0002352 -2.509 0.01242 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4001 on 518 degrees of freedom ## Multiple R-squared: 0.441, Adjusted R-squared: 0.4334 ## F-statistic: 58.37 on 7 and 518 DF, p-value: &lt; 2.2e-16 veri setinde ortalama eğitim düzeyi 12.5 yıldır. Etkileşim terimlerini eğitimin ortalamadan farkı ile de kurabiliriz: summary(lm(log(wage) ~ female + I(educ-12.5) + I(female*(educ-12.5)) + exper+I(exper^2) + tenure+I(tenure^2), data=wage1)) ## ## Call: ## lm(formula = log(wage) ~ female + I(educ - 12.5) + I(female * ## (educ - 12.5)) + exper + I(exper^2) + tenure + I(tenure^2), ## data = wage1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.83265 -0.25261 -0.02374 0.25396 1.13584 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.4184208 0.0440456 32.203 &lt; 2e-16 *** ## female -0.2963450 0.0358358 -8.270 1.14e-15 *** ## I(educ - 12.5) 0.0823692 0.0084699 9.725 &lt; 2e-16 *** ## I(female * (educ - 12.5)) -0.0055645 0.0130618 -0.426 0.6703 ## exper 0.0293366 0.0049842 5.886 7.11e-09 *** ## I(exper^2) -0.0005804 0.0001075 -5.398 1.03e-07 *** ## tenure 0.0318967 0.0068640 4.647 4.28e-06 *** ## I(tenure^2) -0.0005900 0.0002352 -2.509 0.0124 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4001 on 518 degrees of freedom ## Multiple R-squared: 0.441, Adjusted R-squared: 0.4334 ## F-statistic: 58.37 on 7 and 518 DF, p-value: &lt; 2.2e-16 "],["3.13-hipotez-testleri.html", "3.13 Hipotez testleri", " 3.13 Hipotez testleri Her zaman PRF ile ilgili: \\(Y=\\beta_0 + \\beta_1 X + u\\) Boş hipotez: \\(X\\) ile \\(Y\\) arasında bir ilişki yoktur. \\[H_0: \\beta_1 = 0\\] Alternatif hipotez: \\(X\\) ile \\(Y\\) arasında bir ilişki vardır. \\[H_a: \\beta_1 \\neq 0\\] \\(H_0\\) \\(t\\) testi ile sınanabilir. Boş hipotez altında \\(t\\) test istatistiği: \\[t = \\frac{\\hat{\\beta}_1-0}{\\operatorname{se}\\left(\\hat{\\beta}_{1}\\right)}=\\frac{\\hat{\\beta}_1}{\\operatorname{se}\\left(\\hat{\\beta}_{1}\\right)}\\] \\(X\\) ile \\(Y\\) arasında hiç bir ilişki yoksa (yani boş hipotez doğruysa) \\(t\\) istatistiği \\(n-2\\) serbestlik derecesiyle \\(t\\) dağılımına uyar. 3.13.1 t-testi karar kuralı Basit regresyon modelinde boş hipotez \\(H_0: \\beta_1 = 0\\) ve alternatif \\(H_a: \\beta_1 \\neq 0\\) için t testi karar kuralı: Verilmiş bir Tip-I hata olasılığı, \\(\\alpha = Pr(|T|&gt;c_{\\alpha/2}~|~H_0)\\), için hesaplanan \\(t\\) istatistiğinin mutlak değeri kritik değer \\(c_{\\alpha/2}\\)’den büyükse boş hipotez reddedilebilir. \\[t&gt;c_{\\alpha/2}~~ \\mbox{ya da}~~ t&lt;-c_{\\alpha/2}~~\\mbox{ise}~~H_0~~red\\] (Not: Burada \\(T\\), \\(n-2\\) serbestlik derecesine sahip bir \\(t\\) rassal değişkenidir.) Bir boş hipotezin doğru olup olmadığı pratikte hiç bir zaman bilinemez. İki tip hata yapılabilir. Bunların olasılıkları: Tip-I hata olasılığı: \\(Pr(H_0~~ RED~|~H_0~DOĞRU)\\). Tip-II hata olasılığı: \\(Pr(H_0~~ KABUL~|~H_0~YANLIŞ)\\). Bu olasılığı pratikte belirleyemeyiz. 3.13.2 p-değeri Her seferinde tablo kritik değerlerine bakmak yerine \\(\\alpha\\)’yı elimizdeki örneklemden hareketle tahmin etmeye çalışabiliriz. \\(p\\)-değeri: Elimizdeki örneklemden hareketle aynı testi yapsak boş hipotezi kabul etmemizle sonuçlanacak en büyük anlamlılık düzeyi, \\(\\alpha\\), kaçtır? Örnek: \\(n-2=65\\), hesaplanan \\(t\\) istatistiği \\(t=1.82\\) olsun. \\[p-değeri=Pr(T&gt;1.82|H_0) + Pr(T&lt;-1.82|H_0) = 0.0367 + 0.0367 = 0.0734\\] 2*pt(1.82, df=65, lower.tail = FALSE) ## [1] 0.07336374 \\(H_0\\)’ın reddi için en düşük anlamlılık düzeyi=%7.34. Bundan daha yüksek tüm \\(\\alpha\\) düzeylerinde \\(H_0\\) RED. Örneğin, testi \\(\\alpha=0.05\\) düzeyinde yaparsak boş hipotez reddedilemez. \\(p\\)-değeri ne kadar küçükse elimizdeki örneklemde boş hipotez aleyhine kanıt o kadar güçlü demektir. 3.13.3 t-testi: Örnek library(wooldridge) model1 &lt;- lm(wage ~ educ, data = wage1) broom::tidy(model1) ## # A tibble: 2 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -0.905 0.685 -1.32 1.87e- 1 ## 2 educ 0.541 0.0532 10.2 2.78e-22 Denklem formunda yazarsak: \\[\\widehat{wage} = -0.905 + 0.54~ educ,~~~R^2 = 0.165\\] Standart hatalar: \\(se(\\hat{\\beta}_0)=0.685\\), \\(se(\\hat{\\beta}_1)=0.0533\\). Eğim parametresinin anlamlılığına ilişkin t testi: \\[t_{\\beta_1} = \\frac{0.54136}{0.05325} = 10.167 \\sim~t(524)\\] Karar: \\(H_0:\\beta_1=0\\) boş hipotezi alternatif hipotez lehine reddedilir. Hesaplanan t istatistiği \\(\\alpha=0.05\\) anlamlılık düzeyindeki kritik değerden daha büyüktür: \\(|t_{\\beta_1}|&gt;1.96\\). Eğitim düzeyi ücretler üzerinde istatistik bakımından anlamlı bir etkiye sahiptir. p değeri \\(\\alpha=0.05\\) düzeyinden küçüktür (H0 red). 3.13.4 F Testi: Çoklu Doğrusal Kısıtların Testi Regresyondaki \\(t\\) istatistikleri anakütleye ait beta parametrelerinin belli bir sabite eşit olup olmadığını test etmemize yarar. Parametrelerin tek bir doğrusal kombinasyonunun (kısıtın) belli bir sabite eşit olup olmadığının testini ise, önceki örnekte gördüğümüz gibi, değişkenleri dönüştürerek modeli yeniden düzenlemek suretiyle yapıyorduk. Ancak, şu ana kadar hep tek bir kısıtlamaya ilişkin test yapıyorduk. Şimdi çok sayıda kısıt varken nasıl test yapacağımızı görelim. 3.13.5 Dışlama kısıtları Regresyonda yer alan bir değişkenler grubunun birlikte \\(y\\) üzerinde anlamlı bir etkisinin olup olmadığını test etmek istiyoruz. Örneğin şu modelde \\[y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 +\\beta_3 x_3 +\\beta_4 x_4 +\\beta_5 x_5 + u\\] şu hipotezi test etmek istiyoruz: \\[H_0: \\beta_3 =0, \\beta_4=0, \\beta_5=0\\] \\[H_1: \\beta_3 \\neq 0, \\beta_4\\neq 0, \\beta_5\\neq 0\\] Boş hipotez, \\(x_3\\), \\(x_4\\) ve \\(x_5\\) değişkenlerinin birlikte \\(y\\) üzerinde bir etkisinin olmadığını söylemektedir. Alternatif hipotez en az birinin sıfırdan farklı olduğunu söylemektedir. Kısıtlanmamış (UnRestricted) Model \\[y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 +\\beta_3 x_3 +\\beta_4 x_4 +\\beta_5 x_5 + u\\] \\(SSR_{ur},~~~R^2_{ur}\\) Kısıtlanmış (Restricted) Model \\[y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + u\\] \\(SSR_{r},~~~R^2_{r}\\) \\(H_0\\) doğru kabul edildiğinde kısıtlanmış modele ulaşılır. Her iki model ayrı ayrı tahmin edilerek kalıntı kareleri toplamlarındaki değişim \\(F\\) testi yardımıyla karşılaştırılabilir. F test istatistiği \\[F = \\frac{(SSR_r - SSR_{ur})/q}{SSR_{ur}/(n-k-1)}\\sim~~F_{q,n-k-1}\\] \\(SSR_r\\) kısıtlanmış modelin, \\(SSR_{ur}\\) ise kısıtlanmamış modelin Kalıntı Kareleri Toplamıdır. \\(q=df_r-df_{ur}\\): toplam kısıt sayısı, payın serbestlik derecesi (kısıtlanmamış modelin parametre sayısından kısıtlanmış modelin parametre sayısı çıkarılarak bulunabilir) Paydanın serbestlik derecesi ( \\(df_{ur}\\) ) kısıtlanmamış modelin serbestlik derecesine eşittir. Karar kuralı: \\(F&gt;c\\) ise \\(H_0\\) RED. \\(c\\), ilgili \\(F_{k,n-k-1}\\) dağılımında %100\\(\\alpha\\) düzeyindeki kritik değerdir. 3.13.6 F testi için karar kuralı F testi her zaman sağ kuyrukta yapılır. Hesaplanan F değeri verilmiş bir anlamlılık düzeyindeki (alfa) kritik değerden daha büyükse H0 reddedilir. Ya da F testinin p-değeri yeterince küçükse (örneğin alfa = 0.05’den küçükse) boş hipotez reddedilir. 3.13.7 Doğrusal kısıtlar: örnek Aşağıdaki ev değeri modelini düşünelim: \\[\\log(fiyat) = \\beta_0+\\beta_1 \\log(ekspertiz)+\\beta_2 odasay+\\beta_3metrekare+\\beta_4okul + u\\] Burada fiyat evin satış değerini, ekspertiz gayrimenkul uzmanlarınca yapılan değerlemeyi, odasay evdeki toplam oda sayısını, metrekare evin büyüklüğünü, okul ise civardaki okulların kalitesini göstermektedir. İyi işleyen bir gayrimenkul piyasasında ekspertiz ile evin değeri arasında bire bir bir ilişki bekleriz (evin özelliklerini dikkate aldıktan sonra) Ev değerlemesi rasyonel yapıldıysa (piyasada balon yoksa) log(ekspertiz) katsayısı 1, diğer tüm katsayılar 0 olmalı: \\[H_0: \\beta_1 = 1,~ \\beta_2=0,~ \\beta_3 =0,~ \\beta_4 = 0\\] Kısıtlanmamış model: \\[\\log(fiyat) = \\beta_0+\\beta_1 \\log(ekspertiz)+\\beta_2 odasay+\\beta_3metrekare+\\beta_4okul + u\\] Kısıtlanmış model: \\[H_0: \\beta_1 = 1,~ \\beta_2=0,~ \\beta_3 =0,~ \\beta_4 = 0\\] altında kısıtlanmış model: \\[\\log(fiyat) = \\beta_0+\\log(ekspertiz) + u\\] ya da \\[\\log(fiyat) - \\log(ekspertiz) = \\beta_0 + u\\] 3.13.8 Regresyonun Bütün Olarak Anlamlılığı Boş hipotezimiz şudur: regresyona eklenen açıklayıcı değişkenlerin \\(y\\) üzerinde birlikte etkisi yoktur: \\[H_0:\\beta_1=\\beta_2=\\ldots=\\beta_k=0\\] Alternatif hipotez: en az biri sıfırdan farklı olduğunu söyler. Boş hipoteze göre kurulan modelin bir açıklayıcılığı yoktur. Bu boş hipotez altında \\[y = \\beta_0 +u\\] Bu boş hipotez \\(F\\) testiyle sınanabilir. \\(F\\) test istatistiği \\[F = \\frac{R^2/k}{(1-R^2)/(n-k-1)}\\sim~F_{k,n-k-1}\\] Buradaki \\(R^2\\) kısıtlanmamış modelden elde edilen determinasyon katsayısıdır. Standart ekonometri paket programları regresyonun bütün olarak anlamlılığını sınayan F istatistiğini otomatik olarak hesaplar. "],["3.14-regresyon-analizinde-potansiyel-problemler.html", "3.14 Regresyon Analizinde Potansiyel Problemler", " 3.14 Regresyon Analizinde Potansiyel Problemler Hata varyansının sabit olmaması (heteroskedasticity) Hata teriminde otokorelasyon veya dizisel/mekansal korelasyon Fonksiyon biçiminin yanlış olması, doğrusal olmayan ilişkiler Bağımlı değişkende çok küçük ya da büyük değerler (outliers) X’lerde çok büyük ya da küçük değerler (yüksek kaldıraç oranları) Yüksek çoklu doğrusallık (multicollinearity) Potansiyel problemlerin teşhisinde kalıntıların görselleştirilmesi faydalı olabilir. Kalıntıların \\(\\hat{y}\\)’ya veya \\(x\\)’lere göre serpilme çizimi önemli bilgi sunar. Kalıntıların sıfır çevresinde rassal dağılmasını bekleriz. Belirgin bir örüntü genellikle probleme işaret eder. Örnek: Simülasyonla bir veri seti türeterek regresyon modeli tahmin edelim ve tanısal grafikleri çizelim. set.seed(1) # aynı sonuçları elde etmek için n &lt;- 250 x1 &lt;- rnorm(n, mean=0, sd=1) y &lt;- 1 + 2*x1 + rnorm(n, mean=0, sd=1) # popülasyon regresyon modeli biliniyor df1 &lt;- tibble(id=1:n, y, x1) reg_df1 &lt;- lm(y ~ x1, data = df1) # diagnostic plots par(mfrow=c(2,2)) plot(reg_df1) Bu grafiklere tek tek bakalım: plot(reg_df1, which = 1) # RESET spesifikasyon hatası testi # Modellenmeyen doğrusal olmayan ilişkiler var mı? library(lmtest) ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric resettest(reg_df1) # RESET test, H0: spesifikasyon hatası yoktur ## ## RESET test ## ## data: reg_df1 ## RESET = 0.72951, df1 = 2, df2 = 246, p-value = 0.4832 Bu sonuçlara göre (p-değeri=0.48) boş hipotez kabul edilir. Yukarıdaki modelde fonksiyon kalıbı doğru kurulmuştur. Residuals vs Fitted: bu serpilme çiziminin sıfır çevresinde rassal dağılmasını bekleriz. Belirli bir örüntü varsa bu doğrusal olmayan ilişkilerin varlığına işaret edebilir. plot(reg_df1, which = 2) Normal Q-Q: İkinci grafik normal dağılımdan sapmaları gösteren Q-Q grafiğidir. Standardize edilmiş kalıntılar eğer normal dağılırsa aşağı yukarı kesikli çizgi ile çakışmalıdır. Yukarıdaki grafikte kalıntıların normal dağıldığı görülüyor. İstenirse Jarque-Bera gibi normallik testleri ile bu grafikler desteklenebilir. plot(reg_df1, which = 3) Scale-Location: Üçüncü grafik (alt sol) kalıntı ve fit değerlerinin scale-location grafiğini görüyoruz. Dikey eksende standardize edilmiş kalıntıların mutlak değerinin kare kökü yer alıyor. Yine bu grafikte de sıfır çevresinde rassal bir dağılım bekliyoruz. Eğer belirgin bir örüntü varsa bu kalıntıların varyansının sabit olmadığına işaret eder (heteroskedasticity). Ancak bu grafiğin yorumunu fonksiyon kalıbını doğru bir şekilde seçtiğimizden emin olarak yapmalıyız. Ayrıca Breusch-Pagan, White gibi değişen varyans testleri de yapılmalıdır. # Breusch-Pagan değişen varyans testi library(lmtest) bptest(reg_df1) # BP test, H0: sabit varyans ## ## studentized Breusch-Pagan test ## ## data: reg_df1 ## BP = 0.015263, df = 1, p-value = 0.9017 BP test istatistiği oldukça küçüktür. P değeri 0.9 olarak bulunmuştur. Varyansın sabit olduğunu söyleyen boş hipotez reddedilemez. Modelde değişen varyans yoktur. plot(reg_df1, which = 5) Residual vs Leverage: Dördüncü (alt sağ) grafik yüksek etkili gözlemlerin (influential observations - high leverage) saptanmasında kullanılabilir. Bu gözlemler regresyonu önemli ölçüde etkileyen uç değerlerdir. Grafikte kırmızı kesikli çizgi ile Cook’s D (distance) değerleri gösterilmiştir. Bu kırmızı kesikli çizginin dışına düşen değerler yüksek etkili gözlemler olarak düşünülebilir. Cook’s D istatistiği Grafiğe göre yüksek etkili gözlem yoktur. Cook’s D değerlerinin grafiği: plot(reg_df1, which = 4) Ortalama Cook’s D ve Ortalama hatvalues: mean(cooks.distance(reg_df1)) ## [1] 0.004124096 mean(hatvalues(reg_df1)) ## [1] 0.008 Cook’s D Cut-off değeri cutoff &lt;- 3*mean(cooks.distance(reg_df1)) plot(reg_df1, which = 4) abline(h=cutoff,lty=2) "],["3.15-kestirim-prediction.html", "3.15 Kestirim (Prediction)", " 3.15 Kestirim (Prediction) Regresyon analizinin temel amaçlarından biri kestirim (prediction) veya öngörü (forecasting) yapabilmektedir. Kestirim: yatay-kesit verilerle bağımlı değişkenin tahmin edilmesi Öngörü: zaman serisi verileriyle gelecek değerlerin kestirilmesi/tahmin edilmesi Regresyon modelini OLS yöntemiyle çözdükten sonra verilmiş x değerlerini modelde yerine yazarak kestirim değerini oluşturabiliriz. Örneğin \\[\\hat{y} = \\hat{\\beta}_0 + \\hat{\\beta}_1 x_1 + \\hat{\\beta}_2 x_2 +\\ldots+ \\hat{\\beta}_k x_k\\] modelinde kestirim değerleri \\(x_1=c_1\\), \\(x_2=c_2,\\ldots,x_k=c_k\\) olsun. Bilinmeyen kestirim değerine \\(\\theta_0\\) diyelim: \\[\\theta_0 = \\beta_0 + \\beta_1c_1+\\beta_2c_2+\\ldots+\\beta_k c_k\\] OLS tahmincisi: \\[\\hat{\\theta}_0 = \\hat{\\beta}_0 + \\hat{\\beta}_1 c_1 + \\hat{\\beta}_2 c_2 +\\ldots+ \\hat{\\beta}_k c_k\\] Kestirimin %95 Güven Aralığı: \\[\\hat{\\theta}_0 \\pm~2~se(\\hat{\\theta}_0)\\] Verilerde olmayan tekil bir gözlem için oluşturulan kestirimin güven aralığı, ortalama için oluşturulan kestirimin güven aralığından daha geniştir. Tekil gözleme ilişkin kestirim standart hatası çok daha büyüktür. "],["3.16-makine-öğrenmesi-ve-regresyon-analizi.html", "3.16 Makine Öğrenmesi ve Regresyon Analizi", " 3.16 Makine Öğrenmesi ve Regresyon Analizi Makine öğrenmesi “bilgisayarların örnek veriler ya da geçmiş deneyimlerden hareketle kestirim başarılarını en yüksek yapacak şekilde programlanması” biçiminde tanımlanabilir (Alpaydın, Yapay Öğrenme, 2018, s.3) Finansal ve ekonomik verilerle kestirim/öngörü, sınıflandırma, ve kümeleme problemlerinin çözümüne yönelik algoritmaların geliştirilmesi makine öğrenmesinin konusunu oluşturur. Makine öğrenmesi iki gruba ayrılabilir: Gözetimli makine öğrenmesi (supervised machine learning) ve Gözetimsiz makine öğrenmesi (unsupervised machine learning) Gözetimli öğrenmede girdi değişkenleri (özellikler ya da öznitelikler) ile çıktı değişkeni gözlemlenebilir. Her gözleme ait bir çıktı değeri ya da kategorisi (etiketi) mevcuttur. Amaç çıktıyı kestirmekte en başarılı modeli bulmaktır. Örnek: bir kredi başvurusundan hareketle ödeyememe riskini (olasılığını) öngörmek Bir banka geçmişteki kredi başvurularından hareketle bir ödeyememe modeli kurabilir. Krediye başvuran bireyin özellikleri (features) kurulan modelde değerlendirilerek bir kestirim yapılabilir (Örneklem-dışı kestirim-out-of-sample prediction). Gözetimli öğrenme türleri: regresyon problemleri, sınıflandırma problemleri. Gözetimsiz Öğrenmede ise girdi değişkenleri (kestirim değişkenleri ya da öznitelikler) gözlemlense de bir çıktı değişkeni ya da etiket yoktur. Yaygın kullanılan problemler: kümeleme ve boyut küçültme Kümeleme (clustering): bir özellik setinden hareketle homojen gruplar bulunabilir mi? Örneğin benzer özelliklere sahip tüketici grupları, hasta türleri, benzer davranışa sahip seçmen grupları vb. Boyut küçültme (dimensionality reduction): çok sayıda potansiyel kestirim değişkeni arasından en önemlilerinin seçilmesi "],["3.17-regresyon-ve-gözetimli-öğrenme.html", "3.17 Regresyon ve gözetimli öğrenme", " 3.17 Regresyon ve gözetimli öğrenme Tipik bir (gözetimli) makine öğrenmesi problemini aşağıdaki gibi yazabiliriz: \\[y = f(x_1, x_2, \\ldots, x_p) + \\epsilon\\] Burada \\(y\\) çıktı değişkenini (etiketleri), \\(\\{x_1, x_2, \\ldots, x_p\\}\\) ise özellikleri ifade etmektedir. \\(\\epsilon\\) rassal hata terimidir. Bilinmeyen fonksiyon kalıbı \\(f(\\cdot)\\) ile gösterilmiştir. Kestirim Başarısının Ölçümü: Modelin kestirimini şöyle yazalım: \\[\\hat{y} = f(x_1, x_2, \\ldots, x_p)\\] Makine öğrenmesi probleminde amaç kestirim hatasını, \\(y-\\hat{y}\\), en küçük yapmaktır. Tahmin doğruluğu (accuracy) tipik olarak Ortalama Hata Karesi (Mean Squared Error - MSE) ile ölçülür Modelin \\(y = f(x) + \\epsilon\\) olduğunu, tahminin ise \\(\\hat{f}(x)\\) ile gösterildiğini varsayalım. Böyle bir regresyon problemi için Ortalama Hata Karesi (MSE) aşağıdaki gibi tanımlanabilir: \\[MSE = \\frac{1}{n}\\sum_{i=1}^{n}(y_i - \\hat{f}(x_i))^2\\] Burada \\(n\\) gözlemden oluşan bir eğitim (training) veri seti kullanılmıştır. "],["3.18-test-mse.html", "3.18 Test MSE", " 3.18 Test MSE Tipik olarak bir gözetimli öğrenme probleminde eğitim verisinde MSE en küçük olacak şekilde tahmin yapılır. Örnek: Sıradan En Küçük Kareler tahmininde kalıntı kareleri toplamını minimum yapan katsayı tahminleri bulunur. Bir makine öğrenmesi uygulamasında asıl amaç eğitim verisinde modelin performansının ne olduğu değildir. Önemli olan tahminde (eğitimde) kullanılmamış yeni bir veri setinde nasıl performans gösterdiğidir. Eğitimde kullanılmayan, sadece kestirim performansının (doğruluğunun) değerlendirilmesinde kullanılan veri setine test verileri denir. Eğitim MSE’nin en küçük olması test MSE’nin de en küçük olacağı anlamına gelmez. Modelin esnekliği arttıkça MSE(eğitim) azalır. Aşırı uyum (overfitting) tehlikesi vardır. Eğitim Verileri: \\(\\{Y_i, \\mathbf{X}_i\\}_{i=1}^n\\) Test Verileri: \\(\\{Y_{0i}, \\mathbf{X}_{0i}\\}_{i=1}^m\\) Test MSE: \\[MSE_{test} = \\frac{1}{m}\\sum_{i=1}^{m}(y_{0i} - \\hat{f}(x_{0i}))^2\\] Modelin eğitim verilerinden hareketle tahmininden sonra test verileri ile tahmin yapılarak kolayca hesaplanabilir. "],["3.19-aşırı-uyum-ve-makine-öğrenmesi.html", "3.19 Aşırı uyum ve makine öğrenmesi", " 3.19 Aşırı uyum ve makine öğrenmesi Makine öğrenmesi yaklaşımında amaç eğitim verilerinde hatanın en küçük olması değildir. Asıl amaç yeni veri setindeki kestirim başarısıdır. (out-of-sample prediction error). Ancak pratikte elimizde sadece bir veri kümesi vardır. Bu verilerden hareketle örneklem-dışı kestirim başarısını nasıl tahmin edebiliriz? Bunun için elimizdeki verileri rassal olarak iki gruba ayırabiliriz: Örneğin verilerin %80’ini modelin eğitilmesinde, kalan %20’sini ise kestirim hatasının hesaplanmasında kullanabiliriz (test verileri). Buna geçerleme (validation) yaklaşımı denir. Pratikte iki yaklaşım kullanılabilir: (1) Biri-hariç çapraz geçerleme, (2) k-katlı çapraz geçerleme. Zaman serileri için belirli bir t zamanına kadar olan verilerle modeli tahmin edip, t+1, t+2, …., zamanları için öngörü yapabiliriz. Zaman sırasının değişmemesi gerekir. "],["3.20-biri-hariç-çapraz-geçerleme-loocv-leave-one-out-cross-validation.html", "3.20 Biri Hariç Çapraz Geçerleme, LOOCV (Leave-one-out Cross Validation)", " 3.20 Biri Hariç Çapraz Geçerleme, LOOCV (Leave-one-out Cross Validation) Gözlemlerden sadece biri geçerlemede kullanılır; geriye kalan (n-1) gözlem modelin eğitiminde kullanılır. Bu süreç her seferinde bir gözlem eğitimden dışlanacak şekilde n kere tekrarlanır ve her biri için \\(MSE_i\\) elde edilir. Bu \\(n\\) MSE değerinin ortalaması test hata tahminidir: \\[\\mathrm{CV}_{(n)}=\\frac{1}{n} \\sum_{i=1}^{n} \\mathrm{MSE}_{i}\\] "],["3.21-k-katlı-çapraz-geçerleme.html", "3.21 \\(k\\)-Katlı Çapraz Geçerleme", " 3.21 \\(k\\)-Katlı Çapraz Geçerleme Biri-hariç çapraz geçerleme \\(n\\) büyük olduğunda hesaplamada zorluk çıkarabilir. Alternatif olarak gözlemler rassal şekilde \\(k\\) gruba (kat) ayrılabilir. Sırasıyla her kat geçerleme seti olarak kullanılır; geriye kalan gözlemlerle model eğitilir. Sonuçta elimizde \\(k\\) tane MSE değeri vardır. Test hata tahmini bunların ortalamasıdır: \\[\\mathrm{CV}_{(k)}=\\frac{1}{k} \\sum_{i=1}^{k} \\mathrm{MSE}_{i}\\] "],["4-Zaman.html", " 4 Regresyon Analizi: Zaman Serileri", " 4 Regresyon Analizi: Zaman Serileri Kesit veri ile regresyon analizinde, verilerin ilgili anakütleden rassal örnekleme yoluyla elde edildiği varsayımı yapılabilir (bağımsız ve türdeş dağılım, iid). Bu varsayım altında hata terimleri birbiriyle ilişkisiz olur. Ancak zaman serilerinde bu varsayım genellikle gerçekçi olmaz. Tipik olarak zaman serilerinde dizisel bağımlılık görülür. Bu nedenle zaman serileriyle regresyon analizinde bazı yeni varsayımların yapılması gerekebilir. En Küçük Kareler Yöntemi belirli varsayımlar altında sapmasız ve/veya tutarlı, ve etkin olabilir. Bu bölümde zaman serileriyle regresyon analizinin temel özellikleri incelenecektir. "],["4.1-zaman-serileri.html", "4.1 Zaman Serileri", " 4.1 Zaman Serileri \\(t\\) (zaman) ile indekslenmiş \\(\\{Y_t: ~t\\in \\mathbb{T}\\}\\) ile gösterilen tek değişkenli rassal değişkenler kümesine zaman serisi adı verilir (stokastik süreç). İndeks kümesi sonlu ya da sonsuz, sürekli ya da kesikli olabilir. Ekonometri ve istatistik alanlarında zaman serisi denildiği zaman genellikle kesikli zaman indeksi anlaşılır. Zaman indeksi kümesinin birbirine eşit uzaklıkta değerlerden oluştuğu düşünülür, ancak bu şart değildir. Biz burada aksi belirtilmedikçe \\(t_i\\) değerlerinin eşit uzaklıklı olduğunu varsayacağız. Zamanın reel sayı olduğu sürekli zaman ile indekslenmiş rassal değişkenleri kümesi genellikle \\(\\{X(t),~t\\in \\mathbb{T} \\}\\) ile gösterilir. Kesikli zaman için indeks kümesi \\(\\mathbb{T}=\\{0,\\pm 1,\\pm 2,\\ldots\\}\\) ve sürekli zaman için \\(\\mathbb{T}=\\{-\\infty&lt;t&lt;\\infty \\}\\) olarak tanımlanabilir. Stokastik sürecin belirli bir gerçekleşmesini (realizasyonunu) \\(\\{y_t: t=1,2,\\ldots,T\\}\\) ya da \\(\\{y_t\\}_{t=1}^T\\) ile gösterebiliriz. \\(t\\) zamanında gözlemlenen değerler skalar (univariate) ya da vektör değerli (multivariate) olabilir. "],["4.2-rda-zaman-serilerinin-temsili.html", "4.2 R’da Zaman Serilerinin Temsili", " 4.2 R’da Zaman Serilerinin Temsili Zaman serileriyle veri analizinde kullandığımız yazılım ne olursa olsun veri tipine ilişkin özelleştirilmiş fonksiyon ve algoritmaların kullanılması bir zorunluluktur. R programında da, tıpkı diğerlerinde olduğu gibi, veri setinin bir zaman serisi olduğunun tanıtılması gerekir. R’da zaman serilerini temsil etmenin birden fazla yolu vardır. Yaygın olarak kullanılan nesne sınıfları aşağıda tanıtılmıştır. Daha fazla bilgi için bkz. CRAN Task View: Time Series Analysis 4.2.1 ts Nesnesi Temel R’da bir zaman serisi ts nesnesi ile temsil edilebilir. Düzenli aralıklarla ölçülmüş ve kayıp gözlemlerin olmadığı veri setleri için idealdir. Örnek: set.seed(1) x &lt;- rnorm(10) x ## [1] -0.6264538 0.1836433 -0.8356286 1.5952808 0.3295078 -0.8204684 0.4874291 ## [8] 0.7383247 0.5757814 -0.3053884 class(x) ## [1] &quot;numeric&quot; x değişkeninin sınıfı sayısaldır (numeric). Şimdi bir zaman serisi, ts, nesnesi oluşturalım. Zamanın yıllık olarak 2010-2019 arasında ölçüldüğünü farzedelim: ts_annual &lt;- ts(x, start = 2010, frequency = 1) ts_annual ## Time Series: ## Start = 2010 ## End = 2019 ## Frequency = 1 ## [1] -0.6264538 0.1836433 -0.8356286 1.5952808 0.3295078 -0.8204684 0.4874291 ## [8] 0.7383247 0.5757814 -0.3053884 Oluşturulan nesnenin sınıfı ve özellikleri: class(ts_annual) ## [1] &quot;ts&quot; attributes(ts_annual) ## $tsp ## [1] 2010 2019 1 ## ## $class ## [1] &quot;ts&quot; ts_annual vektörünün sınıfı ts’dir. tsp (attribute) zamanın başlangıç, bitiş ve frekansını gösterir. Yıllık veri için frekans 1’dir. Temel R’ın plot fonksiyonu zaman serisi nesnelerini algılar ve grafiği buna uygun olarak çizer: plot(ts_annual) Nümerik vektör x ile grafik: plot(x) Zaman serilerinden oluşan bir değişkenler kümesi: set.seed(22) n &lt;- 120 x1 &lt;- rnorm(n) x2 &lt;- rnorm(n) t &lt;- 1:n y &lt;- 10 + 0.1*t + 2*x1 - 3*x2 + rnorm(n) df1 &lt;- data.frame(y, x1, x2) head(df1) ## y x1 x2 ## 1 11.01752 -0.5121391 -0.6665832 ## 2 17.13793 2.4851837 -0.3467479 ## 3 14.11995 1.0078262 -0.4358330 ## 4 16.11770 0.2928146 -1.9470039 ## 5 11.83468 -0.2089594 -0.8379082 ## 6 17.89354 1.8580924 -0.7415289 Yukarıdaki veri çerçevesinin aylık verilerden oluştuğunu ve 2010m1’den itibaren 10 yıllık bir dönemi kapsadığını düşünelim: ts_monthly &lt;- ts(df1, start = c(2010, 1), end = c(2019, 12), frequency = 12) head(ts_monthly) ## y x1 x2 ## [1,] 11.01752 -0.5121391 -0.6665832 ## [2,] 17.13793 2.4851837 -0.3467479 ## [3,] 14.11995 1.0078262 -0.4358330 ## [4,] 16.11770 0.2928146 -1.9470039 ## [5,] 11.83468 -0.2089594 -0.8379082 ## [6,] 17.89354 1.8580924 -0.7415289 attributes(ts_monthly) ## $dim ## [1] 120 3 ## ## $dimnames ## $dimnames[[1]] ## NULL ## ## $dimnames[[2]] ## [1] &quot;y&quot; &quot;x1&quot; &quot;x2&quot; ## ## ## $tsp ## [1] 2010.000 2019.917 12.000 ## ## $class ## [1] &quot;mts&quot; &quot;ts&quot; &quot;matrix&quot; class(ts_monthly) ## [1] &quot;mts&quot; &quot;ts&quot; &quot;matrix&quot; plot(ts_monthly) Benzer şekilde çeyreklik veriler için frequency = 4 olarak belirlenebilir: ts_quarterly &lt;- ts(runif(8), start = c(2018, 1), frequency = 4) ts_quarterly ## Qtr1 Qtr2 Qtr3 Qtr4 ## 2018 0.7304693 0.7870054 0.8954003 0.3331258 ## 2019 0.8876747 0.6141378 0.7607281 0.5440350 Verilerin bir alt kümesi window() fonksiyonu ile oluşturulabilir. Örneğin, ts_monthly_subset &lt;- window(ts_monthly, start=c(2018,1)) ts_monthly_subset ## y x1 x2 ## Jan 2018 18.40797 -0.33324995 0.10869187 ## Feb 2018 15.74612 -0.39793547 1.45290569 ## Mar 2018 19.74570 -0.50115035 -0.61267109 ## Apr 2018 18.01528 -0.77273822 -0.06516846 ## May 2018 15.36078 -1.71239612 0.26570978 ## Jun 2018 17.60987 -0.79921870 -0.01060245 ## Jul 2018 16.49052 -1.41085475 0.33320645 ## Aug 2018 23.21067 0.53275820 -0.79305213 ## Sep 2018 24.64894 -0.39770077 -1.19191589 ## Oct 2018 19.28710 -0.28435325 0.69395132 ## Nov 2018 24.51503 0.12498413 -1.19316828 ## Dec 2018 27.16400 0.78012669 -1.41040845 ## Jan 2019 19.16921 -0.87559719 0.40811576 ## Feb 2019 15.56407 -1.15936503 1.04478745 ## Mar 2019 19.88641 -0.14586878 0.39343983 ## Apr 2019 17.44377 -1.67842869 0.48269703 ## May 2019 19.31902 -1.32258464 0.02858935 ## Jun 2019 18.43350 -0.55887740 0.41441915 ## Jul 2019 18.84263 -2.48978148 -0.61271368 ## Aug 2019 22.35360 1.17918927 0.76866790 ## Sep 2019 23.95577 0.79370484 -0.31469479 ## Oct 2019 23.80681 1.60743480 0.37070328 ## Nov 2019 27.92537 0.06594797 -1.93087451 ## Dec 2019 20.57888 1.02900536 0.79631138 4.2.2 zoo nesnesi ts objelerinde zaman tanımı sadece nümerik olabilir. Aylık, çeyreklik, yıllık verilerde bu sorun olmasa da düzensiz ölçümlü verilerde ve saatlik gözlemlerin yer aldığı verilerde sorun yaratabilir. Alternatiflerden biri zoo paketidir (ve sınıfı). Bu paket Zeileis and Grothendieck (2005) tarafından yazılmıştır. Detaylar için bkz. : zoo: S3 Infrastructure for Regular and Irregular Time Series (Z’s Ordered Observations). library(zoo) n &lt;- 10 dates &lt;- seq(as.Date(&quot;2020-12-01&quot;), length = n, by = &quot;days&quot;) dates ## [1] &quot;2020-12-01&quot; &quot;2020-12-02&quot; &quot;2020-12-03&quot; &quot;2020-12-04&quot; &quot;2020-12-05&quot; &quot;2020-12-06&quot; ## [7] &quot;2020-12-07&quot; &quot;2020-12-08&quot; &quot;2020-12-09&quot; &quot;2020-12-10&quot; x_zoo &lt;- zoo(x = rnorm(n), order.by = dates) x_zoo ## 2020-12-01 2020-12-02 2020-12-03 2020-12-04 2020-12-05 2020-12-06 2020-12-07 ## 0.82822485 -0.27596111 0.90011072 0.40052611 -2.43993993 1.70488277 -0.35356859 ## 2020-12-08 2020-12-09 2020-12-10 ## -0.40279204 -0.01563910 0.04372756 class(x_zoo) ## [1] &quot;zoo&quot; plot(x_zoo) ts nesnesi bir zoo nesnesine as.zoo() fonksiyonu ile dönüştürülebilir. Tersi için as.ts() fonksiyonu kullanılabilir: zoo_monthly &lt;- as.zoo(ts_monthly) plot(zoo_monthly) Örnek: AirPassengers verileri plot(autoplot.zoo(as.zoo(AirPassengers))) 4.2.3 xts nesnesi Diğer bir alternatif xts (Extensible Time Series) paketidir ve zoo paketini baz alır. Daha fazla detay için bkz. CRAN sayfası: xts: eXtensible Time Series. library(xts) ## ## ################################### WARNING ################################### ## # We noticed you have dplyr installed. The dplyr lag() function breaks how # ## # base R&#39;s lag() function is supposed to work, which breaks lag(my_xts). # ## # # ## # Calls to lag(my_xts) that you enter or source() into this session won&#39;t # ## # work correctly. # ## # # ## # All package code is unaffected because it is protected by the R namespace # ## # mechanism. # ## # # ## # Set `options(xts.warn_dplyr_breaks_lag = FALSE)` to suppress this warning. # ## # # ## # You can use stats::lag() to make sure you&#39;re not using dplyr::lag(), or you # ## # can add conflictRules(&#39;dplyr&#39;, exclude = &#39;lag&#39;) to your .Rprofile to stop # ## # dplyr from breaking base R&#39;s lag() function. # ## ################################### WARNING ################################### ## ## Attaching package: &#39;xts&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## first, last xts_data1 &lt;- xts(x = runif(5), order.by=Sys.Date()-1:5) colnames(xts_data1) &lt;- &quot;var1&quot; xts_data1 ## var1 ## 2023-07-03 0.5986281 ## 2023-07-04 0.4638573 ## 2023-07-05 0.6464816 ## 2023-07-06 0.7256413 ## 2023-07-07 0.2013998 # sunspots data data(&quot;sunspots&quot;) xts_sunspots &lt;- as.xts(sunspots) head(xts_sunspots) ## [,1] ## Jan 1749 58.0 ## Feb 1749 62.6 ## Mar 1749 70.0 ## Apr 1749 55.7 ## May 1749 85.0 ## Jun 1749 83.5 class(xts_sunspots) ## [1] &quot;xts&quot; &quot;zoo&quot; periodicity(xts_sunspots) ## Monthly periodicity from Jan 1749 to Dec 1983 plot(xts_sunspots) Örnek: günlük veriler data(&quot;sample_matrix&quot;) xts_daily &lt;- as.xts(sample_matrix) head(xts_daily) ## Open High Low Close ## 2007-01-02 50.03978 50.11778 49.95041 50.11778 ## 2007-01-03 50.23050 50.42188 50.23050 50.39767 ## 2007-01-04 50.42096 50.42096 50.26414 50.33236 ## 2007-01-05 50.37347 50.37347 50.22103 50.33459 ## 2007-01-06 50.24433 50.24433 50.11121 50.18112 ## 2007-01-07 50.13211 50.21561 49.99185 49.99185 plot(xts_daily) 4.2.4 tsibble nesnesi Başka bir alternatif zaman serisi gruplarının tanımlanmasına izin veren tsibble nesnesidir. tidyverts paketler topluluğunun bir parçasıdır ve R. Hyndman vd tarafından geliştirilmiştir, bkz. tidyverts tidyverts şu paketlerden oluşur: tsibble, fable, feasts, ve tsibbledata. Bu paketlerde yer alan fonksiyonlar tidyverse paketleriyle uyumlu çalışır. Daha fazla detay için bkz tsibble: Tidy Temporal Data Frames and Tools. Ayrıca bkz. Hyndman, R.J., &amp; Athanasopoulos, G. (2019) Forecasting: principles and practice, 3rd edition, OTexts: Melbourne, Australia. tsibble nesnesi oluşturmak için # library(tidyverts) library(tsibble) ## ## Attaching package: &#39;tsibble&#39; ## The following object is masked from &#39;package:zoo&#39;: ## ## index ## The following object is masked from &#39;package:lubridate&#39;: ## ## interval ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, union tsdata1 &lt;- tsibble(year = 2017:2019, var1 = c(100, 90, 105), index = year) tsdata1 ## # A tsibble: 3 x 2 [1Y] ## year var1 ## &lt;int&gt; &lt;dbl&gt; ## 1 2017 100 ## 2 2018 90 ## 3 2019 105 Bir tsibble nesnesinde zamanı temsil eden bir index değişkeni bulunur. Yukarıdaki örnekte zaman indeksi year değişkenidir Örnek: Minimal bir panel veri seti tsdata2 &lt;- tsibble(year = c(rep(2017,3), rep(2018,3)), province = rep(c(&quot;Istanbul&quot;, &quot;Ankara&quot;, &quot;Izmir&quot;),2), GDPpc = c(65195,51922,45102,76769,60249,54305), index = year, key = province ) tsdata2 ## # A tsibble: 6 x 3 [1Y] ## # Key: province [3] ## year province GDPpc ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2017 Ankara 51922 ## 2 2018 Ankara 60249 ## 3 2017 Istanbul 65195 ## 4 2018 Istanbul 76769 ## 5 2017 Izmir 45102 ## 6 2018 Izmir 54305 index(tsdata2) ## year key(tsdata2) ## [[1]] ## province Örnek: Ülke veri seti (tsibbledata paketinden) library(tsibbledata) data(&quot;global_economy&quot;) global_economy ## # A tsibble: 15,150 x 9 [1Y] ## # Key: Country [263] ## Country Code Year GDP Growth CPI Imports Exports Population ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan AFG 1960 537777811. NA NA 7.02 4.13 8996351 ## 2 Afghanistan AFG 1961 548888896. NA NA 8.10 4.45 9166764 ## 3 Afghanistan AFG 1962 546666678. NA NA 9.35 4.88 9345868 ## 4 Afghanistan AFG 1963 751111191. NA NA 16.9 9.17 9533954 ## 5 Afghanistan AFG 1964 800000044. NA NA 18.1 8.89 9731361 ## 6 Afghanistan AFG 1965 1006666638. NA NA 21.4 11.3 9938414 ## 7 Afghanistan AFG 1966 1399999967. NA NA 18.6 8.57 10152331 ## 8 Afghanistan AFG 1967 1673333418. NA NA 14.2 6.77 10372630 ## 9 Afghanistan AFG 1968 1373333367. NA NA 15.2 8.90 10604346 ## 10 Afghanistan AFG 1969 1408888922. NA NA 15.0 10.1 10854428 ## # ℹ 15,140 more rows global_economy veri setinde zaman indeksi Year ve anahtar (key) değişkeni Country’dir. Sıklıkla kullanılan zaman formatları ve ilgili fonksiyonlar (Kaynak: Hyndman and Athanasopoulos (2019) Forecasting: principles and practice, 3rd edition) Interval Class Function Annual integer/double start:end Quarterly yearquarter yearquarter() Monthly yearmonth yearmonth() Weekly yearweek yearweek() Daily Date/difftime as_date(), ymd() Subdaily POSIXt/difftime/hms as_datetime() Mevcut bir zaman serisi nesnesi tsibble nesnesine dönüştürülebilir. Örneğin, library(tsibble) library(tidyverse) library(lubridate) library(xts) library(fpp3) # use built-in daily data on closing prices from xts package data(&quot;sample_matrix&quot;) head(sample_matrix) ## Open High Low Close ## 2007-01-02 50.03978 50.11778 49.95041 50.11778 ## 2007-01-03 50.23050 50.42188 50.23050 50.39767 ## 2007-01-04 50.42096 50.42096 50.26414 50.33236 ## 2007-01-05 50.37347 50.37347 50.22103 50.33459 ## 2007-01-06 50.24433 50.24433 50.11121 50.18112 ## 2007-01-07 50.13211 50.21561 49.99185 49.99185 # convert sample_matrix into tibble and create a date variable df1 &lt;- tibble(date = rownames(sample_matrix), close = sample_matrix[,4] ) df1 &lt;- df1 %&gt;% mutate(date = lubridate::ymd(date)) df1 ## # A tibble: 180 × 2 ## date close ## &lt;date&gt; &lt;dbl&gt; ## 1 2007-01-02 50.1 ## 2 2007-01-03 50.4 ## 3 2007-01-04 50.3 ## 4 2007-01-05 50.3 ## 5 2007-01-06 50.2 ## 6 2007-01-07 50.0 ## 7 2007-01-08 50.0 ## 8 2007-01-09 49.9 ## 9 2007-01-10 50.0 ## 10 2007-01-11 50.2 ## # ℹ 170 more rows tsibble_daily &lt;- as_tsibble(df1, index = date) tsibble_daily ## # A tsibble: 180 x 2 [1D] ## date close ## &lt;date&gt; &lt;dbl&gt; ## 1 2007-01-02 50.1 ## 2 2007-01-03 50.4 ## 3 2007-01-04 50.3 ## 4 2007-01-05 50.3 ## 5 2007-01-06 50.2 ## 6 2007-01-07 50.0 ## 7 2007-01-08 50.0 ## 8 2007-01-09 49.9 ## 9 2007-01-10 50.0 ## 10 2007-01-11 50.2 ## # ℹ 170 more rows Günlük verilerden oluşan bu veri setinden hareketle aylık ortalamaları hesaplayarak yeni bir veri seti oluşturalım. Bunun için önce tsibble::yearmonth() fonksiyonunu kullanarak year_month isminde yeni bir değişken oluşturalım. Bu değişkeni gruplamada kullanacağız. tsibble_monthly &lt;- tsibble_daily %&gt;% mutate(year_month = yearmonth(date)) tsibble_monthly ## # A tsibble: 180 x 3 [1D] ## date close year_month ## &lt;date&gt; &lt;dbl&gt; &lt;mth&gt; ## 1 2007-01-02 50.1 2007 Jan ## 2 2007-01-03 50.4 2007 Jan ## 3 2007-01-04 50.3 2007 Jan ## 4 2007-01-05 50.3 2007 Jan ## 5 2007-01-06 50.2 2007 Jan ## 6 2007-01-07 50.0 2007 Jan ## 7 2007-01-08 50.0 2007 Jan ## 8 2007-01-09 49.9 2007 Jan ## 9 2007-01-10 50.0 2007 Jan ## 10 2007-01-11 50.2 2007 Jan ## # ℹ 170 more rows tsibble_monthly veri setinde zaman indeksi date değişkenidir. Bu aşamada index_by() fonksiyonunu kullanarak özet istatistikleri hesaplayabiliriz (bu dplyr paketindeki group_by() fonksiyonuna benzemektedir). tsibble_monthly2 &lt;- tsibble_monthly %&gt;% index_by(year_month) %&gt;% summarize(close_avr = mean(close), count = n()) tsibble_monthly2 ## # A tsibble: 6 x 3 [1M] ## year_month close_avr count ## &lt;mth&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2007 Jan 50.2 30 ## 2 2007 Feb 50.8 28 ## 3 2007 Mar 49.5 31 ## 4 2007 Apr 49.6 30 ## 5 2007 May 48.3 31 ## 6 2007 Jun 47.5 30 Günlük verilerin zaman grafiği tsibble_daily %&gt;% autoplot(close) Aylık verilerin zaman grafiği tsibble_monthly2 %&gt;% autoplot(close_avr) "],["4.3-klasik-zaman-serisi-ayrıştırması.html", "4.3 Klasik Zaman Serisi Ayrıştırması", " 4.3 Klasik Zaman Serisi Ayrıştırması Toplamsal ayrıştırma \\[X_t = T_t + C_t + S_t + I_t\\] Bileşenler: \\(T_t\\): trend bileşeni: bu yavaş hareket eden uzun dönem bileşenidir. \\(C_t\\): Çevrimsel (Cyclical) bileşen: orta dönemli hareketleri yansıtan konjonktür dalgalanmaları, resesyon ve canlanma gibi dönemleri kapsayan bileşendir. Tipik olarak bir kaç yıl sürebilir. \\(S_t\\): Mevsimsel (Seasonal) bileşen: aylık, çeyreklik, haftalık veya günlük verilerde gözlemlenen yılın aynı dönemlerindeki benzer hareketleri içerir. Finansal zaman serilerinde işlem günü etkisi bu çerçevede değerlendirilebilir. \\(I_t\\): Düzensiz (Irregular) bileşen bu bileşenlerin dışında kalan rassal hareketlerdir. Mevsimsel bileşen aşağı yukarı sabit hareket ediyorsa toplamsal bileşen uygundur. Ancak mevsimsel bileşen serinin düzeyi ile orantılı şekilde artıyorsa çarpımsal ayrıştırma daha uygundur: \\[X_t = T_t \\times C_t \\times S_t \\times I_t\\] Doğal logaritma dönüştürmesi yapılarak mevsimsel hareketler daha stabil hale geliyorsa bu durumda log-toplamsal ayrıştırma tercih edilebilir: \\[\\log(X_t) = T_t + C_t + S_t + I_t\\] Mevsimsel düzeltme: Ayrıştırma yapıldıktan sonra mevsimsel bileşen \\(S_t\\) çıkarılarak mevsimsel düzeltme yapılabilir: \\(\\log(X_t) - S_t = T_t + C_t + I_t\\) 4.3.1 Örnek: Turist sayısı library(forecast) ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo ## ## Attaching package: &#39;forecast&#39; ## The following object is masked from &#39;package:fabletools&#39;: ## ## accuracy # Türkiye&#39;ye gelen toplam turist sayısı, aylık load(&quot;veriler/turist.rda&quot;) turist_ts &lt;- ts(turist$touristnumber, start = c(1990,1), frequency = 12) autoplot(turist_ts) # mevsimsel grafik forecast::ggseasonplot(turist_ts) # log dönüştürme autoplot(log(turist_ts)) # mevsimsel grafik forecast::ggseasonplot(log(turist_ts), year.labels=TRUE, year.labels.left=TRUE) # polar mevsimsel grafik forecast::ggseasonplot(log(turist_ts), polar=TRUE) # mevsimsel alt dönemler ggsubseriesplot(turist_ts) + ylab(&quot;Turist sayısı&quot;) + ggtitle(&quot;Mevsimsel alt seriler: Türkiye&#39;ye gelen turist sayısı&quot;) # mevsimsel alt dönemler, logaritmik skala ggsubseriesplot(log(turist_ts)) + ylab(&quot;Turist sayısı Logaritmik skala&quot;) + ggtitle(&quot;Mevsimsel alt seriler: Türkiye&#39;ye gelen turist sayısı (log)&quot;) # klasik ayrıştırma # çarpımsal turist_ts |&gt; decompose(type=&quot;multiplicative&quot;) |&gt; autoplot() + xlab(&quot;Year&quot;) + ggtitle(&quot;Klasik çarpımsal ayrıştırma: Gelen turist sayısı&quot;) "],["4.4-zaman-serilerinde-bağımlılık.html", "4.4 Zaman Serilerinde Bağımlılık", " 4.4 Zaman Serilerinde Bağımlılık 4.4.1 Otokorelasyon Fonksiyonu (ACF) Örneklem otokovaryans fonksiyonu aralarındaki zaman uzaklığı \\(h\\) olan iki rassal değişken arasındaki kovaryansın bir tahmin edicisidir: \\[\\hat{\\gamma}_h = \\frac{1}{T}\\sum_{t=h+1}^T (y_t-\\bar{y})(y_{t-h}-\\bar{y})\\] Burada \\(\\bar{y}=\\frac{1}{T}\\sum_{t=1}^T y_t\\) örneklem ortalamasıdır. Bir zaman serisinin otokorelasyon fonksiyonu (autocorrelation function, ACF) aşağıdaki gibi tanımlanır: \\[\\rho_h = \\frac{Cov(y_t, y_{t-h})}{\\sqrt{Var(y_t)Var(y_{t-h})}}\\] Durağan süreçler için \\[\\rho_h = \\frac{Cov(y_t, y_{t-h})}{Var(y_t)} = \\frac{\\gamma_h}{\\gamma_0}\\] yazılabilir. Bu durumda ACF sadece \\(h\\)’ye bağlı olarak değişir. \\(T\\) gözlemden oluşan bir zaman serisi gerçekleşmesinden hareketle, \\(\\rho_h\\) aşağıda formülü verilen örneklem otokorelasyon fonksiyonu ile tutarlı bir şekilde tahmin edilebilir: \\[\\hat{\\rho}_h = \\frac{\\hat{\\gamma}_h}{\\hat{\\gamma}_0}\\] Bir zaman serisinin geçmiş değerlerle olan ilişkisinin özetlenmesinde örneklem otokorelasyon fonksiyonu, ACF ya da SACF, kullanılabilir. Geçmişe bağımlılığı yüksek değişkenler için ACF yüksek değerler alır. Bir zaman serisi gerçekleşmesinin örneklem otokorelasyonlarının \\(h=1,2,\\ldots\\) uzaklığına göre grafiğine korelogram adı verilir. Büyük örneklemlerde Merkezi Limit Teoremi’nden hareketle \\[\\hat{\\rho}_j \\sim N\\left(0,\\frac{1}{T}\\right)\\] yazılabilir (Not: \\(\\sqrt{T}\\hat{\\rho}_j \\sim N(0,1)\\)). Öyleyse, sıfır çevresinde %95 güven aralığı \\(\\pm \\frac{1.96}{\\sqrt{T}}\\) formülüyle bulunabilir. Örneklem otokorelasyon değerleri sıfır çevresindeki güven bandının içindeyse sıfır olarak kabul edilebilir. Dışındaysa istatistik bakımından sıfırdan farklıdır. 4.4.2 Pür rassal süreç (white noise) \\(\\{\\epsilon_t: t=1,2,\\ldots\\}\\) ile gösterilen bir stokastik süreç aşağıdaki koşulları sağlıyorsa pür rassal süreç (white noise process) adı verilir: Ortalaması 0’dır, Varyansı, \\(\\sigma^2\\), sabittir, \\(t\\) ve \\(s\\) gibi iki farklı zaman noktasındaki değerler arasındaki kovaryans sıfırdır: \\(Cov(\\epsilon_t, \\epsilon_{s}) = 0,~~t\\neq s\\). Yani seride otokorelasyon yoktur. Bu süreci kısaca \\(\\epsilon_t \\sim wn(0,\\sigma^2)\\) ile gösterebiliriz. 200 gözlemli bir pür rassal süreç gerçekleşmesi Örneklem otokorelasyon fonksiyonu (ACF) "],["4.5-durağanlık.html", "4.5 Durağanlık", " 4.5 Durağanlık Bir zaman serisi, \\(\\{y_t\\}_{t=1}^T\\), aşağıdaki koşulları sağlıyorsa (kovaryans) durağandır: Ortalaması sabittir, zamana göre değişmez. Varyansı sabittir, zamana göre değişmez. İki farklı zamandaki değerler arasındaki otokorelasyon zamana bağlı değildir; ancak uzaklığa bağlı olabilir, yani her \\(t\\) ve herhangi bir tamsayı \\(h\\) için \\[Cov(y_t, y_{t-h}) = E[(y_t-\\mu)(y_{t-h}-\\mu)] = \\gamma_h\\] Kovaryans durağanlık, zayıf durağanlık olarak da isimlendirilir. Durağan bir zaman serisinin birinci ve ikinci momentleri zamana bağlı değildir. Koşulsuz ortalama sabittir ve zaman içinde değişmez. Benzer şekilde koşulsuz varyans, pozitif, sonlu bir sayıya eşittir ve zamanla değişmez. Otokovaryanslar ise sadece iki zaman noktası arasındaki uzaklığa, \\(h\\), bağlıdır, zamanla birlikte değişmez. "],["4.6-birim-kök-ve-durağanlık-testleri.html", "4.6 Birim kök ve durağanlık testleri", " 4.6 Birim kök ve durağanlık testleri Bir değişkenin durağan olup olmadığını birim kök testleriyle anlayabiliriz. Çok sayıda birim kök ve durağanlık testi geliştirilmiştir. Bunların en bilinenleri Dickey-Fuller (DF), Phillips-Perron, ve KPSS tesleridir. DF testi AR(1) fomülasyonuna dayanır: \\[y_t = \\alpha + \\beta y_{t-1} + \\epsilon_t\\] Rassal Yürüyüş (Random Walk) süreci bu modelin özel bir halidir. Birim kök testleri \\(\\beta=1\\) olup olmadığını test eder. Boş ve alternatif hipotezler aşağıdaki gibi yazılabilir: \\[H_0: \\mbox{Değişken durağan değildir}\\Leftrightarrow \\beta=1\\] \\[H_1: \\mbox{Değişken durağandır}\\Leftrightarrow \\beta&lt;1\\] DF ya ADF testi sol kuyruk testidir. Test istatistiği basit t-oranı olsa da dağılımı standart değildir. Kritik değerler modelde sabit terim ve/veya trend olup olmamasına göre değişir. Kritik değerden daha küçük bir ADF test değeri değişkenin durağan olduğuna işaret eder. Daha büyükse H0 kabul edilir, seri durağan değildir. Örnek: library(urca) # birim kök testleri için R paketi library(forecast) # verileri yükle load(&quot;veriler/gsyih_sa_endeks.RData&quot;) # ts nesnesi oluştur: gsyih_ts &lt;- ts(gsyih_sa_endeks$gsyih_sa, start = c(1998,1), frequency = 4) # log dönüştürme lgsyih_ts &lt;- log(gsyih_ts) # zaman serisi grafiği, forecast::autoplot() autoplot(lgsyih_ts) # ADF testi, sabit, trend yok adf1 &lt;- ur.df(lgsyih_ts , type = c(&quot;drift&quot;), # drift (sabit) dahil lags=4, # max gecikme sayısı selectlags=&quot;AIC&quot;) # optimal gecikme AIC ile seçilsin summary(adf1) ## ## ############################################### ## # Augmented Dickey-Fuller Test Unit Root Test # ## ############################################### ## ## Test regression drift ## ## ## Call: ## lm(formula = z.diff ~ z.lag.1 + 1 + z.diff.lag) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.125625 -0.008085 0.005777 0.014417 0.115653 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.024954 0.047181 0.529 0.598 ## z.lag.1 -0.002535 0.009997 -0.254 0.800 ## z.diff.lag -0.148394 0.124711 -1.190 0.237 ## ## Residual standard error: 0.02919 on 83 degrees of freedom ## Multiple R-squared: 0.01748, Adjusted R-squared: -0.006198 ## F-statistic: 0.7382 on 2 and 83 DF, p-value: 0.4811 ## ## ## Value of test-statistic is: -0.2536 7.4818 ## ## Critical values for test statistics: ## 1pct 5pct 10pct ## tau2 -3.51 -2.89 -2.58 ## phi1 6.70 4.71 3.86 ADF test istatistiği \\(-0.254\\) olarak bulunmuştur. %5 düzeyinde kritik değer = \\(-2.89\\). Karar = boş hipotez reddedilemez, GSYİH serisinde birim kök vardır. ADF birim kök kritik değer tablosu: urca::unitrootTable(trend = c(&quot;c&quot;), statistic = c(&quot;t&quot;)) ## 0.010 0.025 0.050 0.100 0.900 0.950 0.975 0.990 ## 25 -3.724 -3.314 -2.986 -2.633 -0.370 0.000 0.327 0.714 ## 50 -3.568 -3.213 -2.921 -2.599 -0.406 -0.040 0.281 0.658 ## 100 -3.497 -3.166 -2.891 -2.582 -0.423 -0.059 0.259 0.632 ## 250 -3.456 -3.139 -2.873 -2.573 -0.433 -0.071 0.247 0.617 ## 500 -3.443 -3.131 -2.867 -2.570 -0.437 -0.075 0.242 0.612 ## Inf -3.430 -3.122 -2.861 -2.567 -0.440 -0.078 0.238 0.607 ## attr(,&quot;control&quot;) ## table trend statistic ## &quot;unitroot&quot; &quot;c&quot; &quot;t&quot; ADF testinin P değeri: urca::punitroot(-0.2536, trend = &quot;c&quot;, statistic = &quot;t&quot;) ## [1] 0.9291699 Sabit + trend durumu: # ADF testi, sabit, trend yok adf2 &lt;- ur.df(lgsyih_ts , type = c(&quot;trend&quot;), # sabit + trend lags=4, # max gecikme sayısı selectlags=&quot;AIC&quot;) # optimal gecikme AIC ile seçilsin summary(adf2) ## ## ############################################### ## # Augmented Dickey-Fuller Test Unit Root Test # ## ############################################### ## ## Test regression trend ## ## ## Call: ## lm(formula = z.diff ~ z.lag.1 + 1 + tt + z.diff.lag) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.132998 -0.005927 0.005060 0.011903 0.099322 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.7999406 0.2829851 2.827 0.00591 ** ## z.lag.1 -0.1919928 0.0689583 -2.784 0.00666 ** ## tt 0.0024316 0.0008764 2.775 0.00684 ** ## z.diff.lag -0.0181634 0.1288199 -0.141 0.88822 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.02808 on 82 degrees of freedom ## Multiple R-squared: 0.1018, Adjusted R-squared: 0.06894 ## F-statistic: 3.098 on 3 and 82 DF, p-value: 0.03126 ## ## ## Value of test-statistic is: -2.7842 7.9564 3.8838 ## ## Critical values for test statistics: ## 1pct 5pct 10pct ## tau3 -4.04 -3.45 -3.15 ## phi2 6.50 4.88 4.16 ## phi3 8.73 6.49 5.47 ADF test istatistiği \\(-2.78\\) olarak bulunmuştur. %5 düzeyinde kritik değer = \\(-3.45\\). Karar = boş hipotez reddedilemez, GSYİH serisinde birim kök vardır. ADF testinin P değeri: # deterministik: &quot;ct&quot; = constant + trend urca::punitroot(-2.78, trend = &quot;ct&quot;, statistic = &quot;t&quot;) ## [1] 0.2046817 Karar: Boş hipotez %5 düzeyinde reddedilemez. GSYİH serisinin birinci farkını alarak testi tekrarlayalım. dlgsyih &lt;- diff(lgsyih_ts) # serinin birinci farkı autoplot(dlgsyih) # ADF testi, sabit adf3 &lt;- ur.df(dlgsyih , type = c(&quot;drift&quot;), # sabit + trend lags=4, # max gecikme sayısı selectlags=&quot;AIC&quot;) # optimal gecikme AIC ile seçilsin summary(adf3) ## ## ############################################### ## # Augmented Dickey-Fuller Test Unit Root Test # ## ############################################### ## ## Test regression drift ## ## ## Call: ## lm(formula = z.diff ~ z.lag.1 + 1 + z.diff.lag) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.128102 -0.008149 0.005030 0.015111 0.112242 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.01251 0.00370 3.381 0.00111 ** ## z.lag.1 -1.08284 0.17817 -6.078 3.68e-08 *** ## z.diff.lag -0.09020 0.15002 -0.601 0.54935 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.02922 on 82 degrees of freedom ## Multiple R-squared: 0.5101, Adjusted R-squared: 0.4982 ## F-statistic: 42.7 on 2 and 82 DF, p-value: 1.962e-13 ## ## ## Value of test-statistic is: -6.0775 18.5108 ## ## Critical values for test statistics: ## 1pct 5pct 10pct ## tau2 -3.51 -2.89 -2.58 ## phi1 6.70 4.71 3.86 ADF test istatistiği \\(-6.078\\) olarak bulunmuştur. %5 düzeyinde kritik değer = \\(-2.89\\). Karar = boş hipotez reddedilir, GSYİH serisinin birinci farkı durağandır. P değeri: # deterministik: &quot;c&quot; = constant urca::punitroot(adf3@teststat[1], trend = &quot;c&quot;, statistic = &quot;t&quot;) ## [1] 7.779951e-08 KPSS testi: H0: seri durağandır # KPSS testi, urca paketi kpss1 &lt;- ur.kpss(dlgsyih) summary(kpss1) ## ## ####################### ## # KPSS Unit Root Test # ## ####################### ## ## Test is of type: mu with 3 lags. ## ## Value of test-statistic is: 0.1122 ## ## Critical value for a significance level of: ## 10pct 5pct 2.5pct 1pct ## critical values 0.347 0.463 0.574 0.739 Karar: KPSS test istatistiği = 0.112’dir. Bu değer kritik değerlerden küçüktür (%10 düzeyinde bile). Öyleyse boş hipotez kabul edilir. Sonuç olarak GSYİH serisinin bir I(1) seri olduğu söylenebilir. "],["4.7-zaman-serileriyle-regresyon-analizi-statik-modeller.html", "4.7 Zaman Serileriyle Regresyon Analizi: Statik Modeller", " 4.7 Zaman Serileriyle Regresyon Analizi: Statik Modeller Elimizde \\(y_t\\) ve \\(x_t\\) ile gösterdiğimiz iki zaman serisi olsun. Eğer \\(x_t\\), \\(y_t\\)’yi aynı zamanda etkiliyorsa bu ilişki aşağıdaki gibi yazılabilir: \\[y_t = \\beta_0 + \\beta_1 x_t + u_t, ~~~t=1,2,\\ldots, n\\] Burada \\(u_t\\) model dışında bırakılmış faktörleri ifade eden bir rassal değişkendir. Model başka zaman dilimleri için de yazılabilir. Örneğin, \\[y_{t-1} = \\beta_0 + \\beta_1 x_{t-1} + u_{t-1}\\] Modelin tahmininde Sıradan En Küçük Kareler (Ordinary Least Squares, OLS) yöntemi kullanılabilir. OLS tahmincileri belirli şartlar altında sapmasız ve en düşük varyanslıdır. \\(t-1\\)’den \\(t\\)’ye değişimi \\(\\Delta\\) ile gösterirsek, \\(\\Delta y_t = y_t - y_{t-1}\\), aşağıdaki modele ulaşırız: \\[\\Delta y_t = \\beta_1 \\Delta x_t + \\Delta u_t\\] Eğer \\(\\Delta u_t = 0\\) ise, \\(x\\)’deki değişimin \\(y\\) üzerindeki etkisi \\[\\frac{\\Delta y_t}{\\Delta x_t} = \\beta_1\\] Eğer \\(x\\) değişkeninin \\(y\\) üzerindeki etkisi aynı zaman diliminde ortaya çıkıyorsa statik modeller uygun olur. Bazı durumlarda bir değişkenin etkisi bir kaç dönem sürebilir. Bu durumda dinamik modeller uygun olur. 4.7.1 Örnek: Statik Phillips Eğrisi # Install packages library(wooldridge) library(dynlm) library(lmtest) library(car) library(forecast) library(tidyverse) # create a ts object inf &lt;- ts(phillips$inf, start=1948, frequency = 1) unem &lt;- ts(phillips$unem, start=1948, frequency = 1) # tüm veriler tsphillips &lt;- ts(phillips, start=1948, frequency = 1) # ts plots autoplot(inf, series = &quot;Enflasyon&quot;) + autolayer(unem, series = &quot;İşsizlik&quot;) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + ggtitle(&quot;ABD enflasyon ve işsizlik: 1948-2003&quot;) # statik regresyon statik &lt;- lm(inf ~ unem, data = phillips) summary(statik) ## ## Call: ## lm(formula = inf ~ unem, data = phillips) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.2176 -1.7812 -0.6659 1.1473 8.8795 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.0536 1.5480 0.681 0.4990 ## unem 0.5024 0.2656 1.892 0.0639 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.972 on 54 degrees of freedom ## Multiple R-squared: 0.06215, Adjusted R-squared: 0.04479 ## F-statistic: 3.579 on 1 and 54 DF, p-value: 0.06389 # dynlm paketi ile (yukarıda yüklemiştik) res1 &lt;- dynlm(inf ~ unem, data = tsphillips) summary(res1) ## ## Time series regression with &quot;ts&quot; data: ## Start = 1948, End = 2003 ## ## Call: ## dynlm(formula = inf ~ unem, data = tsphillips) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.2176 -1.7812 -0.6659 1.1473 8.8795 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.0536 1.5480 0.681 0.4990 ## unem 0.5024 0.2656 1.892 0.0639 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.972 on 54 degrees of freedom ## Multiple R-squared: 0.06215, Adjusted R-squared: 0.04479 ## F-statistic: 3.579 on 1 and 54 DF, p-value: 0.06389 Sonuçlar denklem formunda aşağıdaki gibi yazılabilir: \\[\\widehat{inf} = 1.05+0.502~unem\\] İşsizlikteki bir puanlık bir artış enflasyonu yaklaşık 0.5 puan arttırmaktadır. Bu sonuç Phillips eğrisi ile uyuşmamaktadır. Kalıntıları inceleyelim: # save the residuals from the static model uhat &lt;- ts(resid(statik), start=1948, end=1996) # plot forecast::autoplot(uhat) + geom_point(aes(y=uhat)) + geom_hline(yintercept = 0,linetype=&quot;dashed&quot;, color = &quot;red&quot;) + theme_minimal() # ACF ggAcf(uhat) ACF birinci gecikmede anlamlıdır. Kalıntılarda birinci derece otoregresif ilişki bulunmaktadır. Bunu t testi ile de sınayabiliriz: # AR(1) # dynlm paketi ile kalıntıların bir gecikme üzerine regresyonu: ttestreg &lt;- dynlm(uhat ~ L(uhat)) # L() gecikme işlemi coeftest(ttestreg) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.040596 0.361854 -0.1122 0.9112 ## L(uhat) 0.566445 0.116687 4.8544 1.43e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 L(uhat) katsayısı anlamlıdır. Statik modelin kalıntıları otokorelasyonludur. # Durbin-Watson otokorelasyon testi library(lmtest) # lmtest::dwtest() fonksiyonunu kullanacağız dwtest(res1) ## ## Durbin-Watson test ## ## data: res1 ## DW = 0.80148, p-value = 1.486e-07 ## alternative hypothesis: true autocorrelation is greater than 0 Karar: Kalıntılarda otokorelasyon olmadığını söyleyen boş hipotez reddedilir. Modelde pozitif birinci derece otokorelasyon vardır. (Not: DW testi bağımlı değişkenin gecikmeli değerlerinin yer aldığı modellerde uygulanamaz.) 4.7.2 Örnek: Beklentilerle genişletilmiş Phillips eğirisi Beklentilerle genişletilmiş Phillips eğrisine göre enflasyon sürprizleri ile işsizlik oranı arasında ters yönlü bir ilişki mevcuttur. Enflasyon sürprizi gerçekleşen enflasyon ile beklenen enflasyon arasındaki farktır. Beklenmeyen (sürpriz) enflasyonu ölçebilmemiz için beklentilerle ilgili bir varsayım yapmamız gerekir. Basitlik amacıyla beklentilerin bir önceki dönemdeki enflasyona göre oluşturulduğunu varsayalım. Böylece sürpriz enflasyon cari değerle bir önceki değer arasındaki fark olacaktır (değişim). Modelimiz: \\[inf_t - inf_{t-1} =\\Delta inf_t = \\beta_0 + \\beta_1 unem + u\\] res2 &lt;- dynlm( d(inf) ~ unem, data=tsphillips, end=1996) summary(res2) ## ## Time series regression with &quot;ts&quot; data: ## Start = 1949, End = 1996 ## ## Call: ## dynlm(formula = d(inf) ~ unem, data = tsphillips, end = 1996) ## ## Residuals: ## Min 1Q Median 3Q Max ## -9.1293 -0.7820 0.0611 0.9887 5.3600 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.0306 1.3768 2.201 0.0328 * ## unem -0.5426 0.2302 -2.357 0.0227 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.451 on 46 degrees of freedom ## Multiple R-squared: 0.1078, Adjusted R-squared: 0.0884 ## F-statistic: 5.558 on 1 and 46 DF, p-value: 0.02271 \\[\\widehat{\\Delta inf} = 3.03-0.54~unem\\] uhat2 &lt;- resid(res2) coeftest( dynlm(uhat2 ~ L(uhat2)) ) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.194166 0.300384 0.6464 0.5213 ## L(uhat2) -0.035593 0.123891 -0.2873 0.7752 L(uhat2) katsayısı istatistik bakımından anlamsızdır. Kalıntılarda otokorelasyon yoktur. # Durbin-Watson otokorelasyon testi library(lmtest) # lmtest::dwtest() fonksiyonunu kullanacağız dwtest(res2) ## ## Durbin-Watson test ## ## data: res2 ## DW = 1.7696, p-value = 0.1783 ## alternative hypothesis: true autocorrelation is greater than 0 Karar: Boş hipotez reddedilemez. Kalıntılarda otokorelasyon yoktur. "],["4.8-dinamik-modeller-dağıtılmış-gecikme-modeli.html", "4.8 Dinamik Modeller: Dağıtılmış Gecikme Modeli", " 4.8 Dinamik Modeller: Dağıtılmış Gecikme Modeli \\(x\\)’in etkisinin hem cari dönemde hem de gecikmeli olarak ortaya çıktığını varsayarsak: \\[y_t = \\alpha_0 + \\delta_0 x_t + \\delta_1 x_{t-1} + \\delta_2 x_{t-2} + u_t\\] Bu iki gecikmeli bir sonlu dağıtılmış gecikme modelidir. \\(\\delta_0\\): \\(x\\)’in \\(y\\) üzerindeki ani etkisi (cari dönemde oluşan) \\(\\delta_1\\): bir dönem sonra ortaya çıkan etki, \\(\\delta_2\\): iki dönem sonra ortaya çıkan etki İki dönem sonra ortaya çıkan toplam etki ya da uzun dönem etkisi: \\(\\delta_0+\\delta_1+\\delta_2\\) 4.8.1 Örnek: Vergi teşvikleri ile Doğurganlık ilişkisi Vergi teşvikleri ile doğurganlık arasında nasıl bir ilişki vardır? (kaynak: Wooldridge, 2019) data(fertil3, package=&#39;wooldridge&#39;) tsfertil &lt;- ts(fertil3, start=1913) # gfr = doğurganlık oranı # pe = vergi teşviği (USD cinsinden) # graphs ts.plot(tsfertil[,1:2], col = c(&quot;black&quot;, &quot;red&quot;), lty=1:2, xlab=&quot;&quot;) legend(&quot;topleft&quot;, bty=&quot;n&quot;, lty=1:2, col=c(&quot;black&quot;,&quot;red&quot;), legend=c(&quot; gfr &quot;, &quot; pe &quot;)) # Statik model # ww2 = ikinci dünya savaşı kuklası # pill = doğum kontrol hapı kuklası staticres &lt;- dynlm(gfr ~ pe + ww2 + pill, data = tsfertil) summary(staticres) ## ## Time series regression with &quot;ts&quot; data: ## Start = 1913, End = 1984 ## ## Call: ## dynlm(formula = gfr ~ pe + ww2 + pill, data = tsfertil) ## ## Residuals: ## Min 1Q Median 3Q Max ## -27.0187 -9.6195 0.3393 9.4746 28.0730 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 98.68176 3.20813 30.760 &lt; 2e-16 *** ## pe 0.08254 0.02965 2.784 0.00694 ** ## ww2 -24.23840 7.45825 -3.250 0.00180 ** ## pill -31.59403 4.08107 -7.742 6.46e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 14.69 on 68 degrees of freedom ## Multiple R-squared: 0.4734, Adjusted R-squared: 0.4502 ## F-statistic: 20.38 on 3 and 68 DF, p-value: 1.575e-09 # dynlm paket ile dinamik model # Note: L(pe) = birinci gecikme # L(pe,2) = ikinci gecikme dynres &lt;- dynlm(gfr ~ pe + L(pe) + L(pe,2) + ww2 + pill, data = tsfertil) summary(dynres) ## ## Time series regression with &quot;ts&quot; data: ## Start = 1915, End = 1984 ## ## Call: ## dynlm(formula = gfr ~ pe + L(pe) + L(pe, 2) + ww2 + pill, data = tsfertil) ## ## Residuals: ## Min 1Q Median 3Q Max ## -24.6461 -9.5409 -0.0312 8.3378 29.1295 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 95.87050 3.28196 29.211 &lt; 2e-16 *** ## pe 0.07267 0.12553 0.579 0.5647 ## L(pe) -0.00578 0.15566 -0.037 0.9705 ## L(pe, 2) 0.03383 0.12626 0.268 0.7896 ## ww2 -22.12650 10.73197 -2.062 0.0433 * ## pill -31.30499 3.98156 -7.862 5.63e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 14.27 on 64 degrees of freedom ## Multiple R-squared: 0.4986, Adjusted R-squared: 0.4594 ## F-statistic: 12.73 on 5 and 64 DF, p-value: 1.353e-08 # pe katsayıları birlikte anlamlı mı? # F test. H0: all pe coefficients are=0 linearHypothesis(dynres, matchCoefs(dynres,&quot;pe&quot;)) ## Linear hypothesis test ## ## Hypothesis: ## pe = 0 ## L(pe) = 0 ## L(pe, 2) = 0 ## ## Model 1: restricted model ## Model 2: gfr ~ pe + L(pe) + L(pe, 2) + ww2 + pill ## ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 67 15460 ## 2 64 13033 3 2427.1 3.973 0.01165 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 F istatistiği 3.973 ve p-değeri 0.01 olarak bulundu. Boş hipotez %5 düzeyinde reddedilir. Katsayılar birlikte anlamlıdır # Uzun dönem etkisi katsayıların toplamına eşittir: b &lt;- coef(dynres) b[&quot;pe&quot;]+b[&quot;L(pe)&quot;]+b[&quot;L(pe, 2)&quot;] ## pe ## 0.1007191 # Uzun dönem etkisi istatistik bakımından anlamlı mı? # F test. H0: uzun dönem katsayısı LRP=0 # car::linearHypothesis() fonksiyonu ile doğrusal hipotezler test edilebilir: linearHypothesis(dynres,&quot;pe + L(pe) + L(pe, 2) = 0&quot;) ## Linear hypothesis test ## ## Hypothesis: ## pe + L(pe) + L(pe, 2) = 0 ## ## Model 1: restricted model ## Model 2: gfr ~ pe + L(pe) + L(pe, 2) + ww2 + pill ## ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 65 15358 ## 2 64 13033 1 2325.8 11.421 0.001241 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Boş hipotez reddedilir. LRP sıfırdan farklıdır. "],["4.9-vektör-otoregresyon-var-modeli.html", "4.9 Vektör Otoregresyon (VAR) modeli", " 4.9 Vektör Otoregresyon (VAR) modeli VAR (vector autoregression) modeli bir değişkenin \\(t\\) zamanındaki değerini kendi geçmişiyle ve diğer değişkenlerinin geçmiş değerleriyle açıklamaya ya da öngörmeye çalışır. Örneğin \\(y_t\\) ve \\(x_t\\) için gecikme uzunluğu 1 olan VAR, yani VAR(1) \\[y_t = c_1 + a_{11} y_{t-1} + b_{11} x_{t-1} + \\epsilon_{1t}\\] \\[x_t = c_2 + a_{21} y_{t-1} + b_{21} x_{t-1} + \\epsilon_{2t}\\] VAR(2) \\[y_t = c_1 + a_{11} y_{t-1} + a_{12} y_{t-2}+ b_{11} x_{t-1}+ b_{12} x_{t-2} + \\epsilon_{1t}\\] \\[x_t = c_2 + a_{21} y_{t-1} + a_{22} y_{t-2}+ b_{21} x_{t-1}+ b_{22} x_{t-2} + \\epsilon_{2t}\\] Benzer şekilde daha fazla gecikmeler ( \\(p\\) ) eklenerek VAR modeli genişletilebilir. Hangi değişkenlerin ekleneceği alan bilgisi ve teorik modellerden hareketle belirlenebilir. VAR(p) modelleri özünde ateorik, istatistiksel modellerdir. Değişkenlerin kısa dönem davranışını betimlemede oldukça faydalıdırlar. Bu nedenle ağırlıklı olarak öngörü amacıyla kullanılırlar. Her bir denklem Sıradan En Küçük Kareler (OLS) yöntemiyle tahmin edilebilir. Değişkenlerin durağan olması gerekir. Trend-durağan değişkenler için uygun trend teriminin eklenmesi mümkündür. 4.9.1 Örnek: BIST100 ve Döviz kurları için bir VAR modeli # Aylık veriler load(&quot;veriler/bist_usd.rda&quot;) bist100 &lt;- ts(bist_usd$bist100, start = c(2003,1), frequency = 12) usd &lt;- ts(bist_usd$usd, start = c(2003,1), frequency = 12) # log birinci farklar dlbist100 &lt;- 100*diff(log(bist100), 1) dlusd &lt;- 100*diff(log(usd), 1) data_bist_usd &lt;- cbind(dlbist100, dlusd) autoplot(data_bist_usd) # vars paketini aktive edelim library(vars) # VAR gecikme uzunluğu (order) VARselect(data_bist_usd, lag.max = 12) ## $selection ## AIC(n) HQ(n) SC(n) FPE(n) ## 2 2 1 2 ## ## $criteria ## 1 2 3 4 5 6 7 ## AIC(n) 6.714192 6.674453 6.694696 6.715384 6.696493 6.721448 6.750012 ## HQ(n) 6.752198 6.737797 6.783378 6.829403 6.835849 6.886142 6.940043 ## SC(n) 6.808256 6.831227 6.914180 6.997577 7.041395 7.129060 7.220333 ## FPE(n) 824.020543 791.927833 808.145779 825.081633 809.706137 830.263958 854.456631 ## 8 9 10 11 12 ## AIC(n) 6.768890 6.793784 6.791292 6.824178 6.831227 ## HQ(n) 6.984259 7.034491 7.057336 7.115560 7.147946 ## SC(n) 7.301921 7.389525 7.449742 7.545338 7.615096 ## FPE(n) 870.921108 893.109202 891.175367 921.333430 928.286055 Akaike bilgi kriterine (AIC) göre gecikme sayısı p=2 olarak seçildi. var1 &lt;- VAR(data_bist_usd, type=&quot;const&quot;, p = 2) var1 ## ## VAR Estimation Results: ## ======================= ## ## Estimated coefficients for equation dlbist100: ## ============================================== ## Call: ## dlbist100 = dlbist100.l1 + dlusd.l1 + dlbist100.l2 + dlusd.l2 + const ## ## dlbist100.l1 dlusd.l1 dlbist100.l2 dlusd.l2 const ## 0.006114682 0.166023613 0.096908754 0.035791774 1.082146089 ## ## ## Estimated coefficients for equation dlusd: ## ========================================== ## Call: ## dlusd = dlbist100.l1 + dlusd.l1 + dlbist100.l2 + dlusd.l2 + const ## ## dlbist100.l1 dlusd.l1 dlbist100.l2 dlusd.l2 const ## -0.06044030 0.56727131 0.05178815 -0.24093899 0.68014746 summary(var1) ## ## VAR Estimation Results: ## ========================= ## Endogenous variables: dlbist100, dlusd ## Deterministic variables: const ## Sample size: 225 ## Log Likelihood: -1386.689 ## Roots of the characteristic polynomial: ## 0.492 0.492 0.3414 0.3049 ## Call: ## VAR(y = data_bist_usd, p = 2, type = &quot;const&quot;) ## ## ## Estimation results for equation dlbist100: ## ========================================== ## dlbist100 = dlbist100.l1 + dlusd.l1 + dlbist100.l2 + dlusd.l2 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## dlbist100.l1 0.006115 0.071128 0.086 0.9316 ## dlusd.l1 0.166024 0.165782 1.001 0.3177 ## dlbist100.l2 0.096909 0.075069 1.291 0.1981 ## dlusd.l2 0.035792 0.157863 0.227 0.8208 ## const 1.082146 0.581892 1.860 0.0643 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Residual standard error: 7.936 on 220 degrees of freedom ## Multiple R-Squared: 0.009925, Adjusted R-squared: -0.008076 ## F-statistic: 0.5514 on 4 and 220 DF, p-value: 0.6982 ## ## ## Estimation results for equation dlusd: ## ====================================== ## dlusd = dlbist100.l1 + dlusd.l1 + dlbist100.l2 + dlusd.l2 + const ## ## Estimate Std. Error t value Pr(&gt;|t|) ## dlbist100.l1 -0.06044 0.03360 -1.799 0.07342 . ## dlusd.l1 0.56727 0.07831 7.244 7.27e-12 *** ## dlbist100.l2 0.05179 0.03546 1.460 0.14560 ## dlusd.l2 -0.24094 0.07457 -3.231 0.00142 ** ## const 0.68015 0.27488 2.474 0.01410 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Residual standard error: 3.749 on 220 degrees of freedom ## Multiple R-Squared: 0.2573, Adjusted R-squared: 0.2438 ## F-statistic: 19.05 on 4 and 220 DF, p-value: 1.805e-13 ## ## ## ## Covariance matrix of residuals: ## dlbist100 dlusd ## dlbist100 62.986 -8.756 ## dlusd -8.756 14.055 ## ## Correlation matrix of residuals: ## dlbist100 dlusd ## dlbist100 1.0000 -0.2943 ## dlusd -0.2943 1.0000 # Serial korelasyon testi, kalıntılar white noise olmalı sertest &lt;- serial.test(var1, lags.pt = 12, type = &quot;PT.asymptotic&quot;) sertest ## ## Portmanteau Test (asymptotic) ## ## data: Residuals of VAR object var1 ## Chi-squared = 31.78, df = 40, p-value = 0.8199 plot(sertest, names = &quot;dlbist100&quot; ) plot(sertest, names = &quot;dlusd&quot; ) "],["4.10-granger-nedensellik-testi.html", "4.10 Granger-nedensellik testi", " 4.10 Granger-nedensellik testi Adında geçse de Granger-nedensellik testi klasik nedensellik kavramıyla karıştırılmamalıdır. Granger-nedensellik testi aslında öngörülebilirlik testidir. Basit (iki değişkenli) bir VAR(2) modelinin ilk denklemini düşünelim: \\[y_t = c_1 + a_{11} y_{t-1} + a_{12} y_{t-2}+ b_{11} x_{t-1}+ b_{12} x_{t-2} + \\epsilon_{1t}\\] Eğer \\(x\\), \\(y\\)’nin Granger-nedeni ise bu modelde yer alan \\(x\\)’in gecikmeli katsayılarının birlikte 0 olmaması gerekir. Yani istatistiksel bakımdan anlamlı olmalılar. Tersi durumda \\(x\\), \\(y\\)’nin Granger-nedeni değilse \\(x\\)’in gecikmelerinin katsayıları birlikte istatistik bakımından anlamsızdır. Boş ve alternatif hipotezler: \\[H_0: x,~y\\mbox{&#39;nin Granger-nedeni değildir}\\Leftrightarrow b_{11}=b_{12}=0\\] \\[H_1: x,~y\\mbox{&#39;nin Granger-nedenidir}\\Leftrightarrow b_{11}\\neq b_{12}\\neq 0\\] Model tahmin edildikten sonra standart F testiyle sınanabilir. Boş hipotez verilerle uyumluysa, \\(y_t\\)’yi öngörmekte \\(x\\)’in geçmiş değerlerinin önemli olmadığı sonucu çıkar. Modelin gecikme uzunluğu \\(p\\) bilgi kriterleriyle (örneğin Akaike Information Criterion - AIC) seçilebilir. Minimum AIC değerini veren \\(p\\) tercih edilir. Modelin kalıntıları white noise olmalıdır. 4.10.1 Örnek Önceki kısımda tahmin ettiğimiz USD ve BIST100 VAR(2) modeli sonuçlarından hareketle Granger-nedensellik testlerini hesaplayalım. # Granger nedensellik testi gc1 &lt;- causality(var1, cause = &quot;dlbist100&quot;) gc1 ## $Granger ## ## Granger causality H0: dlbist100 do not Granger-cause dlusd ## ## data: VAR object var1 ## F-Test = 3.1097, df1 = 2, df2 = 440, p-value = 0.04559 ## ## ## $Instant ## ## H0: No instantaneous causality between: dlbist100 and dlusd ## ## data: VAR object var1 ## Chi-squared = 17.932, df = 1, p-value = 2.289e-05 dlbist100 dlusd’nin Granger-nedeni değildir diyen boş hipotez %5 düzeyinde reddedilebilir (p-değeri = 0.046). Borsa endeksindeki aylık değişimler döviz kurlarındaki aylık değişimleri öngörmekte başarılıdır. # Granger nedensellik testi gc2 &lt;- causality(var1, cause = &quot;dlusd&quot;) gc2 ## $Granger ## ## Granger causality H0: dlusd do not Granger-cause dlbist100 ## ## data: VAR object var1 ## F-Test = 0.6559, df1 = 2, df2 = 440, p-value = 0.5195 ## ## ## $Instant ## ## H0: No instantaneous causality between: dlusd and dlbist100 ## ## data: VAR object var1 ## Chi-squared = 17.932, df = 1, p-value = 2.289e-05 dlusd dlbist100’ün Granger-nedeni değildir diyen boş hipotez kabul edilebilir (p değeri 0.5195). Döviz kurlarındaki değişim borsa endeksindeki değişimleri öngörmekte başarılı değildir. VAR modeliyle öngörü: forecast(var1, h=12) %&gt;% autoplot() "],["4.11-kurmaca-regresyon-problemi.html", "4.11 Kurmaca Regresyon Problemi", " 4.11 Kurmaca Regresyon Problemi Trend-durağan değişkenlerle kurulan zaman serisi regresyonlarında trend ihmal edilirse çıkarsamalar yanlış olur. Benzer şekilde fark-durağan değişkenlerle kurulan zaman serisi regresyonları, trend eklense bile yanlış çıkarsamaya neden olur. Yani sonuçlar kurmacadır. Birim kök testleri sonucunda farkı alındığında durağanlaşan değişkenlerin olduğu modellerde regresyon sonuçlarının kurmaca olmadığını nasıl anlarız? Eğer değişkenler arasında eşbütünleşme ilişkisi varsa regresyon sonuçları uzun dönem ilişkisini yansıtır. Yani sonuçlar kurmaca değildir. Eşbütünleşme yoksa sonuçlar kurmaca olabilir. "],["4.12-eşbütünleşme-cointegration.html", "4.12 Eşbütünleşme (cointegration)", " 4.12 Eşbütünleşme (cointegration) \\(y_t\\) ve \\(x_t\\)’nin fark-durağan olduğunu düşünelim (bunu birim kök testleriyle sınayabiliriz) Basit modelde \\[y_t = \\beta_0 + \\beta_1 x_t + u_t\\] hata terimi \\(u_t\\) durağansa \\(y_t\\) ve \\(x_t\\) eşbütünleşiktir. Bu ADF birim kök testi ile sınanabilir. Bu yaklaşımın adı Engle-Granger eşbütünleşme (cointegration) testidir. Eğer \\(u_t\\) durağan değilse değişkenler eşbütünleşik değildir. Bu durumda statik model uzun dönem denge ilişkisini yansıtmaz. Finans ve iktisatta çok sayıda eşbütünleşme örneği bulunabilir. Çoğu zaman arbitraj mekanizması ile iki ya da daha fazla fark-durağan değişken uzun dönemde birbirlerine bağlı olarak hareket ederler. Kısa dönemde sapmalar mümkün olsa da bunlar geçicidir. Spot ve futures fiyatları: bir varlığın zamanın farklı noktalarındaki fiyatları arasında uzun dönemde bir denge ilişkisi beklenir. Tek fiyat kuralı (Law of One Price - LOP): homojen bir malın farklı coğrafi piyasalarda benzer şekilde hareket etmesi beklenir. Aradaki fark ticaret maliyetlerini yansıtır. İki fiyat arasındaki fark taşıma maliyetlerinden yüksekse arbitraj olanağı doğar; ticaret yoluyla fiyatlar dengelenir. Satın alma gücü paritesi (Purchasing Power Parity - PPP): iki ülkenin fiyatlar genel düzeyinin birbirlerine oranı ile nominal döviz kurları arasında uzun dönem bir denge ilişkisi beklenir. Hisse senedi fiyatları ile kar payları (dividends) arasında uzun dönem denge ilişkisi. Gayrimenkul fiyatları ile kira ilişkisi, vb. "],["4.13-engle-granger-eşbütünleşme-testi.html", "4.13 Engle-Granger eşbütünleşme testi", " 4.13 Engle-Granger eşbütünleşme testi EG testinin ilk adımında aşağıdaki model OLS ile tahmin edilir \\[\\hat{y}_t = \\hat{\\alpha} + \\hat{\\beta} x_t\\] Eğer bu iki seri eşbütünleşik ise kalıntı, \\(\\hat{u}_t = y_t - \\hat{\\alpha} - \\hat{\\beta} x_t\\), durağan olmalıdır, I(0). İkinci adımda kalıntılara birim kök testi, örneğin ADF testi, uygulanır. Böylece kalıntıların durağan olup olmadığı araştırılır. Kritik değerler ADF kritik değerlerinden farklıdır. EG testinin boş hipotezi \\[H_0: u_t~\\mbox{durağan değildir (Eşbütünleşme yok)}\\] alternatif: \\[H_1: u_t~\\mbox{durağandır (Eşbütünleşme var)}\\] Boş hipotez altında kurmaca regresyon mevcuttur (eşbütünleşme yok). Boş hipotezin reddi değişkenlerin eşbütünleşik olduğu anlamına gelir. Bu durumda kısa dönemde bir hata düzeltme modeli tahmin edilebilir. Değişkenler eşbütünleşik değilse birinci farkları alınarak bir dinamik model, VAR, vs. kurulabilir. "],["4.14-hata-düzeltme-modeli.html", "4.14 Hata Düzeltme Modeli", " 4.14 Hata Düzeltme Modeli Hata düzeltme modeli (Error Correction Model - ECM) eşbütünleşik değişkenler için tanımlanabilir. Örnek olarak kira ve ev fiyatları ilişkisini ele alalım. \\(r_t\\) logaritmik kira, \\(p_t\\) ise logaritmik ev fiyatları endeksi olsun. Her iki değişken de fark-durağan olsun (birinci farkları durağan). Ayrıca \\(r_t\\) ve \\(p_t\\) eşbütünleşik olsun. Yani \\[s_t = r_t - \\beta p_t\\sim~\\mbox{Durağan}\\] uzun dönem denge ilişkisinden sapmaları gösterir ve eşbütünleşik modeller için her zaman durağandır. Bu iki değişken arasındaki kısa dönem ilişkisi bir ECM ile betimlenebilir: \\[\\begin{aligned} \\Delta r_t &amp;= \\delta s_{t-1} + \\Delta r_t \\mbox{ gecikmeleri} + \\Delta p_t \\mbox{ gecikmeleri} + sabit + hata\\\\ &amp;= \\delta (r_{t-1} - \\beta p_{t-1})+ \\Delta r_t \\mbox{ gecikmeleri} + \\Delta p_t \\mbox{ gecikmeleri} + sabit + hata \\end{aligned}\\] Hata düzeltme parametresi: \\(\\delta&lt;0\\) (ayarlanma hızı) Önceki dönemde \\(s_{t-1}&gt;0\\) ise yani kiralar denge ilişkisinin üzerindeyse \\(\\delta&lt;0\\) olduğundan sonraki dönemde \\(\\delta\\) kadar azalır. Kiralar denge ilişkisine doğru ayarlanır. Tersi durumda isa kiralar yukarı yönlü hareket ederek denge ilişkisine yaklaşır. 4.14.1 Örnek: 3-aylık ve 6-aylık hazine bonosu faiz oranları eşbütünleşik mi? library(wooldridge) r6 &lt;- ts(intqrt$r6, start = 1950, frequency = 4) r3 &lt;- ts(intqrt$r3, start = 1950, frequency = 4) spr &lt;- r6-r3 autoplot(cbind(r6, r3)) intreg1 &lt;- dynlm(r6 ~ r3) summary(intreg1) ## ## Time series regression with &quot;ts&quot; data: ## Start = 1950(1), End = 1980(4) ## ## Call: ## dynlm(formula = r6 ~ r3) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.1379 -0.1583 -0.0251 0.1155 1.1803 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.135374 0.054867 2.467 0.015 * ## r3 1.025899 0.007709 133.081 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2584 on 122 degrees of freedom ## Multiple R-squared: 0.9932, Adjusted R-squared: 0.9931 ## F-statistic: 1.771e+04 on 1 and 122 DF, p-value: &lt; 2.2e-16 Tahmin sonuçları: \\[\\widehat{r6}_t = 0.135 + 1.03 r3_t\\] \\(r3_t\\)’nin katsayı tahmini bire çok yakındır; beklenndiği gibi bu iki değişken arasında birebir ilişki vardır. Kalıntıların birim kök içermediğinin testi (Engle-Granger testi): # Residuals from the static regression uhat &lt;- residuals(intreg1) autoplot(uhat) library(urca) summary( ur.df(uhat , type = c(&quot;drift&quot;), selectlags=&quot;AIC&quot;)) ## ## ############################################### ## # Augmented Dickey-Fuller Test Unit Root Test # ## ############################################### ## ## Test regression drift ## ## ## Call: ## lm(formula = z.diff ~ z.lag.1 + 1 + z.diff.lag) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.01607 -0.13502 -0.03502 0.09798 1.07234 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.00385 0.02257 -0.171 0.865 ## z.lag.1 -0.63207 0.11208 -5.639 1.17e-07 *** ## z.diff.lag -0.14605 0.09148 -1.597 0.113 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2492 on 119 degrees of freedom ## Multiple R-squared: 0.3814, Adjusted R-squared: 0.371 ## F-statistic: 36.69 on 2 and 119 DF, p-value: 3.867e-13 ## ## ## Value of test-statistic is: -5.6392 15.9425 ## ## Critical values for test statistics: ## 1pct 5pct 10pct ## tau2 -3.46 -2.88 -2.57 ## phi1 6.52 4.63 3.81 \\[\\begin{aligned}\\widehat{\\Delta \\hat{u}}_t =&amp; -0.004 -0.632 \\hat{u}_{t-1} -0.146 \\Delta \\hat{u}_{t-1} \\\\&amp;~~~~(0.023)~~~~(0.112) ~~~~~~~~~~(0.091) \\end{aligned}\\] \\[EG = \\frac{-0.632}{0.112}=-5.64\\] ADF kritik değerleri kullanılmamalıdır. EG kritik değerleri farklıdır. Wooldridge (2016) Tablo 18.4’de verilen %1 kritik değeri -3.90’dır. EG test değeri bu değerden daha küçük olduğu için \\(H_0\\) reddedilir. Bu iki değişken eşbütünleşiktir. Hata düzeltme modeli: # an ECM ecm1 &lt;- dynlm(d(r6) ~ L(uhat) + d(r3) + L(d(r3))) summary(ecm1) ## ## Time series regression with &quot;ts&quot; data: ## Start = 1950(3), End = 1980(4) ## ## Call: ## dynlm(formula = d(r6) ~ L(uhat) + d(r3) + L(d(r3))) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.03253 -0.13392 -0.02236 0.09877 1.00188 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -4.226e-05 2.227e-02 -0.002 0.9985 ## L(uhat) -7.678e-01 8.794e-02 -8.731 1.96e-14 *** ## d(r3) 9.912e-01 1.786e-02 55.494 &lt; 2e-16 *** ## L(d(r3)) -3.690e-02 1.807e-02 -2.042 0.0434 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2456 on 118 degrees of freedom ## Multiple R-squared: 0.9646, Adjusted R-squared: 0.9637 ## F-statistic: 1072 on 3 and 118 DF, p-value: &lt; 2.2e-16 \\[\\widehat{\\Delta r6_t} = -0.00004-0.77\\hat{u}_{t-1}+0.99\\Delta r3_t - 0.04\\Delta r3_{t-1}\\] Hata düzeltme (EC) terimi, veya ayarlanma hızı, \\(-0.77\\) olarak tahmin edilmiştir. Beklendiği gibi negatif işaretli ve anlamlıdır. 6-aylık faiz oranları denge ilişkisinin 1 puan üzerindeyse izleyen dönemde yaklaşık 0.77 puan azalacaktır. "],["4.15-vektör-hata-düzeltme-modeli-vec-vs.-var.html", "4.15 Vektör Hata Düzeltme Modeli (VEC) vs. VAR", " 4.15 Vektör Hata Düzeltme Modeli (VEC) vs. VAR Seviyelerde durağan olmayan ve aralarında eşbütünleşme ilişkisi olmayan değişkenlerin olduğu sistemlerde Tüm değişkenlerin birinci farkları alınarak durağanlaştırılır Birinci farklarla VAR(p) model kurularak öngörü modelleri geliştirilebilir Seviyelerde durağan olmayan ancak aralarında bir eşbütünleşme ilişkisi olan değişkenlerin olduğu sistemlerde Uzun dönem ilişkisini betimleyen bir statik model kurulabilir Kısa dönem davranışını betimlemek amacıyla birinci farklarla bir VAR kurulur ve bu modele uzun dönem ilişkisinden sapmalar eklenir (VEC modeli) "],["4.16-çok-değişkenli-modellerde-eşbütünleşme.html", "4.16 Çok değişkenli modellerde eşbütünleşme", " 4.16 Çok değişkenli modellerde eşbütünleşme Elimizde \\(k\\) birinci farkı alınınca durağanlaşan, yani \\(I(1)\\) değişken varsa bunlar arasında en fazla \\(k-1\\) tane eşbütünleşme ilişkisi olabilir. Eğer bu değişkenlerin bir doğrusal bileşkesi durağan ise yani \\[\\beta_1 y_{1t} + \\beta_2 y_{2t} +\\ldots+ \\beta_k y_{kt} \\sim~I(0)\\] sağlayan \\(\\beta\\) katsayıları bulunabilirse bu değişkenlerin eşbütünleşik olduğu söylenebilir. Bu durumda uzun dönem ilişkisi aşağıdaki gibi yazılabilir: \\[y_{1t} - \\beta_2 y_{2t} - \\beta_3 y_{3t} - \\ldots - \\beta_k y_{kt} = u_t\\sim~I(0)\\] burada \\(\\beta_1=1\\) olarak normalize edildi. \\(k\\) değişkenin olduğu bir sistemde en fazla \\(r\\), \\(0&lt;r&lt;k\\), doğrusal bağımsız eşbütünleşme vektörü bulunabilir. Değişkenler eşbütünleşik ise kısa dönem davranışları vektör hata düzeltme modelleri ile özetlenebilir(VEC) Engle-Granger yöntemi çok değişkenli durumlarda genellikle uygulanmaz. Bunun için uygulamada daha çok VAR yaklaşımını baz alan Johansen yaklaşımı kullanılır. Johansen eşbütünleşme testleri maksimum olabilirlik tahmin çerçevesi içinde geliştirilmiştir. Johansen testleri (Trace ve Max Eigenvalue) kullanılarak eşbütünleşme vektörleri tahmin edilebilir. Detaylar için daha ileri düzeyde zaman serisi kaynaklarına başvurulabilir, örneğin, Hamilton (1994, Time Series Analysis), Lutkepohl (2005, Introduction to Multiple Time Series Analysis). "],["5-Rmarkdown.html", " 5 RMarkdown ile Raporlama ", " 5 RMarkdown ile Raporlama "],["5.1-r-markdown-nedir.html", "5.1 R Markdown Nedir?", " 5.1 R Markdown Nedir? R Markdown veri analizinde kullanılan programlar ile buradan elde edilen sonuçların tartışıldığı metni birleştiren bir platform sunar. RStudio tarafından geliştirilmiştir, bkz. https://rmarkdown.rstudio.com/index.html. Ayrıca hızlı bir başlangıç için bkz. https://rmarkdown.rstudio.com/lesson-1.html. Rmd uzantılı R markdown dosyaları özünde bir text dosyasıdır. knitr paketiyle bu dosyada yer alan komutlar bir markdown (md) dosyasına dönüştürülür. Daha sonra pandoc yardımıyla istenen dosya formatlarına dönüştürülür. Dosya formatları html, pdf veya docx olabilir. Bir R markdown dosyası oluşturmak için RStudio menüsünde yer alan basit şablon kullanılabilir. Bunun için sol üst köşede yer alan menüden New file -&gt; R Markdown seçilir. Dosya ismi ve çıktı türü seçildikten sonra R markdown dosyayı oluşturulur: R markdown dosyası {knitr} ile işlendikten sonra çıktı ayrı bir pencerede ya da RStudio’da sağ altta yer alan Viewer penceresinde görülebilir. "],["5.2-başlık-ve-diğer-seçenekler.html", "5.2 Başlık ve diğer seçenekler", " 5.2 Başlık ve diğer seçenekler R Markdown dosyasında en üstte --- ile başlayıp biten kısımda raporun başlığı ve çıktı türü ve diğer seçenekler yer alır. "],["5.3-programların-eklenmesi.html", "5.3 Programların eklenmesi", " 5.3 Programların eklenmesi R programı eklemek için ```{r} ile başlayıp ``` ile biten sınırlandırıcılar kullanılabilir. Ya da RStudio menüsünden aynı işlem yapılabilir. "],["5.4-program-opsiyonları.html", "5.4 Program opsiyonları", " 5.4 Program opsiyonları Programların nasıl çalıştırılacağı, sonuçların son dokümanda gösterilip gösterilmeyeceği, hata veya uyarı mesajlarının yazılıp yazılmayacağı gibi çeşitli opsiyonları belirlemek için: Bu tercihler sadece ilgili program parçası için geçerlidir (lokaldir). Opsiyonları global olarak belirlemek için: "],["5.5-metin.html", "5.5 Metin", " 5.5 Metin R kod parçaları dışındaki kısım metin olarak algılanır. Buraya dilediğimiz gibi tasarlayabiliriz. Tipik olarak veri analizinin sonuçları tartışılabilir. Bölüm, alt-bölüm başlıklarını belirlemek için # kullanılabilir. "],["5.6-grafikler.html", "5.6 Grafikler", " 5.6 Grafikler Grafikler R programlarıyla çizilebilir (bkz.Rmd-sablon.Rmd). Eğer elimizdeki bir resim dosyasını eklemek istersek ![](dosya-adi.png) komutu kullanılabilir. Bu dosyanın aynı klasörde yer alması gerekir. "],["5.7-tablolar.html", "5.7 Tablolar", " 5.7 Tablolar Tablo eklemek için bkz. https://rmarkdown.rstudio.com/lesson-7.html "],["5.8-r-markdown-cheatsheets.html", "5.8 R Markdown Cheatsheets", " 5.8 R Markdown Cheatsheets https://rmarkdown.rstudio.com/lesson-15.html "],["5.9-örnek-türkiyede-illerde-yaşam-indeksi-göstergeleri-2015.html", "5.9 Örnek: Türkiye’de İllerde Yaşam İndeksi Göstergeleri (2015)", " 5.9 Örnek: Türkiye’de İllerde Yaşam İndeksi Göstergeleri (2015) R proje klasörü ve RMarkdown kullanımına ilişkin bir örnek için bkz.: https://htastan.github.io/RMarkdown-Ornek/RMarkdown_Ornek Github klasörü için bkz.: https://github.com/htastan/RMarkdown-Ornek "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
